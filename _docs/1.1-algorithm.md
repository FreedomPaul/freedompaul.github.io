---
title: "算法"
permalink: /docs/algorithm
key: docs-1-1-algorithm
---

### 算法

> 参考：《算法导论》

#### 1. 认识算法

> Qs：{
> 	#0.什么是算法？
> 	#1.为什么算法值得研究？
> 	#2.相对于计算机中使用的其他技术来说算法的作用是什么？
> }

>Q #0：什么是算法？

非正式地说，**算法（algorithm）** 就是任何良（明确）定义的计算过程，该过程取某个值或值的集合作为**输入**并产生某个值或值的集合作为**输出**。
也就是说，**算法**就是把**输入**转换成**输出**的计算步骤的一个序列。
或者说，**算法**是用于求解良（明确）规定的**计算问题**工具。
问题的陈述一般指定了所需的 _输入_/_输出_ 关系。
由此，**算法** 描述了一个特定的计算过程，用于实现这种 _输入_/_输出_ 关系

如果**算法**在每个 **输入** 实例上都以正确的输出结束，那么这样的算法是**正确**的，并认为这个正确的算法解决了给定的计算问题。
反之，不正确的算法对某些输入实例可能根本不结束，也可能以不正确的输出结束。
但在少数情况下，这种不正确的算法只要具备**可控的错误率**也被认为是“正确”的。
注：我们只关心正确的算法。

**算法** 可以用**自然语言（如英语）**描述**计算机程序**或**硬件设计**。
注：必须精确地描述所要遵循的计算过程。



>Q #1.为什么算法值得研究？

算法的实际应用有很多，如下：
* `人类基因工程`：识别人类DNA中的所有10万个基因，确定构成人类DNA的30亿个化学基对的序列，在数据库中存储这类信息并为数据分析开发工具。
* `搜索引擎`：互联网使得全世界的人能够快速地访问与检索大量信息，使用搜索引擎快速地找到特定信息所在的网友。
* `电子商务`：它使得货物与服务能够以电子方式洽谈与交换，并且它依赖于个人信息（如信用卡号、密码和银行账单等）的保密性，必须使用**公钥密码**与**数字签名**这种核心技术，而这种技术是以**数值算法**和**数论**为基础的。
* `资源分配`：制造业和其他商务企业常常需要按**最有益的方式**分配**稀有资源**，例如：
	* 石油公司希望知道在什么地方设置油井，以便最大化预期的利润；
	* 政治候选人想确定在什么地方花钱购买竞选广告，以便最大化赢得竞选的机会；
	* 航空公司希望按尽可能最廉价的方式把乘务员分配到班机上，以确保每个航班被覆盖并且满足政府有关乘务员调度的法规；
	* 互联网服务提供商希望确定在什么地方放置附加的资源，以便更有效地服务其顾客。
以上类似的例子都可以用**线性规划**求解。

更具体一些，**算法**能够解决如下的具体问题：
* `确定最短道路`：给定一张交通图，图上标记有每对相邻十字路口之间的距离，如何确定从一个十字路口到另一个十字路口的**最短道路**。如果不允许穿过自身的道路，可能的路线会有多少？在所有的可能路线中，如何选择一条最短的？大体的解决方案如下：
	* 1.把交通图建模为一个图，
	* 2.寻找图中从一个顶点到另一个顶点的最短路径。
* `两条符号序列的最长公共子序列`：给定两个有序的符号序列$X=< x_1,x_2,...,x_m >$和$Y=< y_1,y_2,...,y_n >$，求出$X$和$Y$的**最长公共子序列**。若$X$有m个符号且$Y$有n个符号，则$X$和$Y$分别有$ 2^m $和$ 2^n $个可能的子序列。如果m和n很大，那么选择$X$和$Y$的所有可能子序列做匹配将花费昂贵的时间。可以使用**动态规划**技术有效地求解该问题。
* `拓扑排序`：给定一个依据部件库的机械设计，其中每个部件可能包含其他部件的实例，需要依次列出这些部件，以使每个部件出现在使用它的任何部件之前。若该设计由n个部件组成，则存在$n!$这可能的顺序。因为**阶乘函数**甚至比**指数函数**增长还快，如果部件数量很大，就不能~~先列出每种可能的顺序，再验证每种顺序是否可行~~。可以使用**拓扑排序**技术有效求解该问题。
* `寻找凸壳`：给定平面上的n个点，寻找这些点的**凸壳**。`凸壳`是包含这些点的最小的凸多边形。

综合来看，大多数有趣的算法问题具有两个特征：
* 存在许多**候选解**，但绝大多数**候选解**都没有解决手头的问题。
	* 寻找一个真正的解或最好的解可能是一个很大的挑战。
* 存在**实际应用**。
	* 如**最短路径**的问题。

但要注意：**算法解决的每个问题并不都有一个容易识别的候选解集**。

**建议**：$ 有关算法的书 = 一本“菜谱” $ 

如果某天遇到一个问题，不能用一个已有的算法解决它，那么可以使用一些**算法设计与分析**的技术去进行如下环节：
* 设计新的算法
* 证明该算法的正确性
* 理解该算法的效率（算法的速度：算法花多长时间产生结果）

但是仍然存在一些问题并没有有效的解法，这类问题的一个子集被称为**NP完全性**
**NP完全问题**的有趣点：
* 虽然没有有效的解法，但无法证明**NP完全问题**不存在有效的解法。
* **NP完全问题集**具有一个非凡的性质：
	* 如果任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法
* 有几个**NP完全问题**类似于一些有已知有效算法的问题。

有些**NP完全问题**能够在实际应用中反映出来。
与其花费许多时间去寻找某一个NP完全问题的有效算法，还不如证明该问题是**NP完全性**，如果证明成立，那么可以开发一个有效的“近似“算法。

多核计算机解决了单核计算机的重大问题：由于功率密度随时钟速度**超线性**地增加，一旦时钟速度变得足够快，CPU将**有熔化的危险**。
**建议**：$ 多核计算机 \approx 多台顺序执行的单核计算机 $
多核计算机是一类”并行计算机“。
为了从多核计算机获得最佳的性能，设计算法时必须考虑**并行性**，建立**多核的”多线程“算法**模型。


>Q #2.相对于计算机中使用的其他技术来说算法的作用是什么？

**假设**：计算机是无限快的并且计算机存储器是免费的。
在这种场景下求解问题时，即便在好的软件工程实践的范围内求解该问题，最终都会选择最容易实现的算法。

但事实是：**计算机并不是无限快的，存储器也不是免费的**。
计算时间是一种有限资源，存储器中的空间也是一种有限资源。
因此我们需要**通过有效的算法合理地使用这些资源**。

在有限的资源下，同一问题的不同算法在效率方面通常具有显著的差别。

我们应该把**算法**看作是一种**技术**。
整个系统的性能不但依赖于**选择快速的硬件**，而且还依赖于**选择有效的算法**。

在其他先进的计算机技术中，都或多或少地使用着**算法技术**。
算法是当代计算机中使用的大多数技术的核心。
”**Having a solid base of algorithmic knowledge and technique** is one characteristic that separates the truly skilled programmers from the novices.“
使用现代计算技术，如果你对算法懂得不多，你也可以完成一些任务。
但是，如果你有一个好的算法背景，那么你可以做的事情就多得多。


#### 2. 算法设计与分析的框架

> 《算法导论》2、3、4、5章

**算法**可以描述为**伪代码**的程序。
**伪代码**的优点

* 伪代码可以使用最清晰、最简洁的表示方法说明给定的算法。
* 伪代码不关心软件工程的问题。
	* 为了更简洁地表达算法的本质，常常忽略~~数据抽象、模块性和错误处理的问题~~。

**伪代码**的规则 

* $ 缩进 = 块结构 $，可大大提高代码的清晰性。
* 使用`while`,`for`,`repeat-until`,...循环和使用`if-else`,...条件结构;
	* **退出循环后，循环计数器保留先前值**；
	* $ to = 递增循环计数器 $
	* $ downto = 递减循环计数器 $
	* $ by = 递增（减）量 $
* 使用`//`注释
* $ i=j=e $ 等价于：
	* $ j=e $，$ i=j $
* 如果没有指定说明，一般使用`局部变量`
* 使用`数组名[下标]`访问数组元素
* $ 复合数据 = 对象 $，$ 一个数组或对象的变量 = 指向表示数组或对象的数据的一个指针  $，属性记号`.`允许`串联`，$ 空指针 = NIL $
* 过程的参数是`按值传递`（参数的副本）的；对象传递时，仅复制指向对象数据的指针，不进行`深复制`；数组传递时，仅传递指向数组的指针。
* 单一的`return`语句可以返回多个值。
* 布尔运算符`and`和`or`都是`短路`的。
* `error`表示一个错误，调用过程负责处理该错误。



> Q #0：如何证明算法的正确性？

为了**证明算法的正确性**，可以使用**循环不变式（ loop invariant）**。

`循环不变式（ loop invariant）`的三条性质

* `初始化（Initialization）`: 在循环的第一次迭代之前是正确的。
* `保持（Maintenance）`: 如果在循环的迭代之前为真，则在下一个迭代之前仍为真。
* `终止（Termination）`: 当循环终止时，不变式为我们提供了一个有用的属性，帮助我们证明算法是正确的。

注：以上三条性质都需要证明。

当`初始化（Initialization）`和`保持（Maintenance）`成立时，在循环的每次迭代之前**循环不变式（ loop invariant）**为真。
它们的证明 $ \approx $ 数学归纳法 ，即：
* 数学归纳法： 为了证明某条性质成立，需要证明一个基本情况和一个归纳步。
* `初始化（Initialization）`和`保持（Maintenance）`的证明方法：
	*  “基本情况”：证明第一次迭代之前**循环不变式（ loop invariant）**成立
	*  “归纳步”：证明从一次迭代到下一次迭代**循环不变式（ loop invariant）**成立

对于`终止（Termination）`的证明方法，可以将**循环不变式（ loop invariant）**与**循环终止条件**相结合，证明算法的正确性。
注：`终止（Termination）`的证明方法 $ \not \approx $ 数学归纳法，因为：
* 数学归纳法：其中的归纳步是无限使用的
* `终止（Termination）`的证明方法：当循环终止时，停止“归纳步”。

`循环不变式（ loop invariant）`的应用：略！


##### 2.1. 算法分析

###### 2.1.1 机器模型

在算法分析中，需要一种**机器模型**作为对真实计算机的抽象。
这种**机器模型**包含有特定技术和成本的资源模型。

这里的**机器模型**是一种通用的**单核**且具有**随机访问**的机器，被称为**RAM模型**。
>注：不能滥用**RAM模型**！
>建议：真实计算机如何设计，**RAM模型**就如何设计。

在**RAM模型**中，指令是顺序执行的。
这个**RAM模型**是并没有精确地定义各个方面（指令和成本）。

在**RAM模型**中，包含有真实计算机中常用的指令（所有指令都需要`常量时间`）：
* `算术指令`：$ +, -, \times, \div, \%,  \lceil \rceil , \lfloor \rfloor $
* `数据移动指令`：$ 装入，存储，复制 $
* `控制指令`： $ 条件转移，无条件转移，子程序调用，子程序返回 $
* `灰色区域`：其他特定的指令 -----**应尽量避免使用这些指令**

在**RAM模型**中，数据类型有：
* `整数型`
* `浮点实数型`

在**RAM模型**中，并没有对真实计算机的内存层次进行建模，故不存在**内存模型**。




###### 2.1.2 基于`RAM模型`的`算法分析`


**算法分析**的目的是预测`当前算法`所需的资源（内存、通信带宽、计算机硬件等）。
但主要注重的是**计算时间**的度量。

通常一个问题存在多种**候选算法**，通过对这些**候选算法**的分析，选出一种**最优的算法**。

采用**RAM模型**分析算法是一个挑战，因为不仅需要洞察能力，还需要很多的数学工具，如：
* 组合学
* 概率论
* 代数


因为 对每个可能的输入有不同的算法行为，所以 需要**一种方法**可以用**简单的、易于理解的公式**的形式总结算法的各种行为。简单地说，这种方法的所要解决的问题是：**如何表达特定算法的分析结果**。

>Q #0：如何表达特定算法的分析结果？

一般来说，算法需要的时间与输入的规模同步增长，所以通常把**一个算法的运行时间**描述为**一个关于输入规模的函数**。这里，存在两个术语：
* **输入规模**：`输入规模`依赖于所要研究的问题，对于研究的每个问题，需指出所使用的输入规模量度。
* **运行时间**：一个算法在特定输入上的`运行时间`是执行的基本操作数或步数，这时，可以使用这样的`观点`:**执行每行伪代码需要常量时间**，
	* 也就是说，虽然一行与另一行可能需要不同数量的时间，但可以假定$ 第i行的每次执行需要的时间是c_i,其中c_i是一个常量 $。

这样，一个算法的**运行时间**最初是**使用所有语句的含$ c_i $的表达式**，经过代数化简后最终得到是**一个更加简明、更容易处理的最简式**。

算法的**运行时间**通常存在三种情况：
* 最坏运行时间：由最坏的输入规模产生
* 平均运行时间：由给定规模的所有输入的平均值产生 or 由**随机算法**产生的随机输入产生的**期望运行时间**作为平均运行时间
* 最好运行时间：由最好的输入规模产生

基于`RAM模型`的`算法分析`主要集中于只求**最坏运行时间**，即对规模为n的任何输入，算法的最长时间。

> Q #0.1 为什么要集中于只求**最坏运行时间**？

其理由如下：
* 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个**上界**。
* 对于某些算法，最坏情况经常出现。
* 大多时候，平均运行时间会倾向于最坏情况。

> Q #0.1 End

已经知道：**一个算法的运行时间**就是**一个自变量为输入规模的函数**。
可以进行抽象，由于一种函数表明了一种变化趋势，可以从该变化趋势得出函数的**变化率**或**变化速度**，反映到算法的**运行时间**上，就有了**增长率**或**增长量级（Order of growth）**的概念。
并且，由于当**输入规模**很大时，该函数的低阶项和常数项变得不那么重要，故运行时间的**增长量级**主要考虑函数的高阶项。

如果一个算法的最坏情况运行时间具有更低的**增长量级**，那么这个算法就是有效的。
在较小的输入规模下，由于低阶项和常数项的存在，使得运行时间具有较高**增长量级**的算法是有效的。
但在足够大的输入规模下，运行时间具有较低**增长量级**的算法是有效的。



当输入规模足够大到只有运行时间的**增长量级（Order of growth）**时，我们要研究算法的**渐近**效率。
在研究算法的**渐近**效率的过程中，我们所关心的是：**当输入规模无限增加至某个极限值时，算法的运行时间如何随着输入规模的变大而增加**，最终得到一个满足除了很小的输入外的所有情况的渐近地更有效的算法。
并且，可以使用几种标准方法简化算法的**渐近分析**：
* 渐近记号：
	* $ \Theta $
	* $ O 与 \omicron $
	* $  \Omega 与 \omega   $
	* 等式和不等式中的渐近记号
* 标准记号与常用函数
	* 单调性
	* $ \lfloor   \rfloor $ 与 $ \lceil   \rceil $
	* 模运算
	* 多项式
	* 指数
	* 对数
	* 阶乘
	* 多重函数
	* 多重对数函数
	* 斐波那契数


在对一个算法的平均情况分析的过程，需要使用**概率分析技术**得出**随机算法**，这个算法做出一些随机的选择，以允许进行概率分析，从而产生**期望的运行时间**来作为平均运行时间。
> 第5章 概率分析和随机算法



....




##### 2.2.算法设计

可以选择使用的**算法设计技术**有很多。

###### 2.2.1 分治算法（Divide-and-Conquer）
> 2.3.1-2.3.2 分治策略  Divide-and-Conquer

**递归型算法**的思想是：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。
这种递归型算法遵循**分治算法（Divide-and-Conquer）**的思想：将原问题**分解**为几个规模较小但类似于原问题的子问题，递归地**求解**这些子问题，然后再**合并**这些子问题的解，从而得到原问题的解。对其思想进行拆解可得：
* **分解**原问题为若干子问题，它们是原问题的规模较小的实例。
* **解决**这些子问题，递归地求解各子问题。**若子问题的规模足够小，则可直接求解**。
* **合并**这些子问题的解成原问题的解。

对于**递归型算法**和**分治算法（Divide-and-Conquer）**，我们都可以用**递归方程（递归式）**描述它们的运行时间，该方程根据在较小输入上的运行时间，描述在输入规模为n的问题上的总运行时间，然后使用**数学工具**求解该方程，从而给出这些算法的性能上的界。
对于**分治算法（Divide-and-Conquer）**，它的运行时间的**递归方程（递归式）**依赖于它的思想。
具体地说，假设$ T(n) $ 是规模为n的一个问题的运行时间。
若问题的输入规模的最大值为常量c，即$ n \le c  $，则直接求解得出需要$O(1)$的常数时间。
假设把原问题分解为a个子问题，每个子问题的输入规模是原问题的$ {1 \over b} $。
为了求解一个输入规模为$ {n \over b} $的子问题，需要$ T({n \over b}) $的时间，所以需要$ aT({n \over b}) $的时间可求解a个子问题。
如果分解问题成子问题的时间是$ D(n) $ ，合并子问题的解成原问题的解的时间是$ C(n) $ ，那么可以得到如下的**递归方程（递归式）**：
$$ T(n) = \begin{cases}
   \Theta(1) &\text{if } n \le c \\
   a T({n \over b}) + D(n) +  C(n) &\text{其他} 
\end{cases} $$

> 第4章 分治策略  Divide-and-Conquer



.....



**************