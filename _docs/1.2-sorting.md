---
title: "排序"
permalink: /docs/sorting
key: docs-1-2-sorting
---

### 排序

> 《算法导论》6、7、8章

**排序问题**的形式定义 ：
$$ 输入：一个含有n个数的序列<a_1,a_2,...,a_n>。\\
输出:输入序列的一个排列（重排）<a'_1,a'_2,...,a'_n>，满足a'_1 \le a'_2 \le ... \le a'_n。$$
这样的输入序列$ <a_1,a_2,...,a_n> $称为排序问题的一个**实例**，它通常是一个n元数组。
通常来说，**问题实例**由计算该问题解所需的（满足问题陈述中强加的各种约束的）输入组成。
因为大多数程序使用**排序**作为一个**中间步**，所以**排序是计算机科学中的一个基本操作**。
因此，已有许多好的**排序算法**供我们使用。

**排序的研究对象：关键字**
在实际中，待排序的数很少是单独的数值，它们通常是包含**记录（record）**的数据集的一部分。
每个记录包含一个**关键字（key）**，每个记录的关键字就是**排序的研究对象**，即排序问题中要重排的值。
记录的剩余部分由**卫星数据（satellite data）**组成，通常与关键字一同存取。
在实际中，当一个排序算法重排关键字，也必须要重排卫星数据。
如果每个记录包含大量的卫星数据，通常重排指向记录的指针的数组，而不是记录的本身，这样可以降低数据移动量。

排序算法只是为了得到有序的顺序的方法，无论我们是对单个数字排序还是对包含许多字节的卫星数据的大型记录排序。
它们是从成熟的程序中抽象出来的。
因此，**排序问题的输入通常假定是由数字组成**。
在实际应用中，我们可以从概念上轻松地将这样的排序算法转换为实际场景下的排序算法，但在处理一些细节问题的过程中会是一项挑战。

**排序的重要性**
排序是算法研究中最基础的问题，其原因有：
* 应用需要对信息进行排序。
* 很多算法需要排序作为中间步。
* 很多重要的算法设计技术都体现在多年研究者所设计的排序算法中。
* 在实现排序算法时会出现很多工程问题。

**排序算法**

|排序算法|最坏情况运行时间|平均情况\期望运行时间|说明|
|:------------:|------------|-------------------|:------------:|
|**`比较`** |           |     |    |
|  插入排序 | $\Theta(n^2)$ | $\Theta(n^2)$|   |
|  归并排序 | $\Theta(n\lg n)$ | $\Theta(n\lg n)$|  |
|  堆排序   | $O(n\lg n)$ | - |   |
|  快速排序 | $\Theta(n^2)$ | 期望：$\Theta(n\lg n)$| 背景：概率论  |
| **`其他`** |    |   |   |
|  计数排序 | $\Theta(k+n)$ | $\Theta(k+n)$|$数据项均在集合\{ 0,1,..,k \}$ |
|  基数排序 | $\Theta(d(n+k))$ | $\Theta(d(n+k))$| $每位数据项都是d位数的整数，每位数字可能取k个值$  |
|  桶排序 | $\Theta(n^2)$ | 平均：$\Theta(n)$| $假定关键字是[0,1)内服从均匀分布的n个实数$ <br>背景：概率论 |

#### `比较`排序算法

##### 0. `比较`排序算法的性质

对于`比较`排序算法，都有一个性质：
>在排序的最终结果中，各元素的次序依赖于它们之间的比较。

##### 1. 插入排序


插入排序：为了排序n个项，该算法所花时间大致等于$ {c_1}{n^2} $，其中$ c_1 $是一个不依赖于n的常数。也就是说，该算法所花时间大致与$ n^2 $成正比。

P9 插入排序
P14 插入排序的分析

对于少量元素的排序，**插入排序**是一个有效的算法。
**插入排序**的工作方式类似于**排序一手扑克牌**，具体如下：
>开始时，左手为空，且桌子上的牌面向下。
然后，每次从桌子上拿走一张牌并将它插入左手中正确的位置。
为了找到一张牌的正确位置，从右到左将它与已在手中的每张牌进行比较。
拿在左手上的牌总是排序好的，这些牌之前是桌子上牌堆中顶部的牌。

于是，将以上描述转换为伪代码算法`INSERTION-SORT`，它的参数是一个包含长度为n的要排序的数组$A[1..n]$。
该算法**原址**排序输入的数，即算法在数组A中重排这些数，在任何时候，最多只有其中的常数个数存储在数组外面。
算法`INSERTION-SORT`结束时，输入数组A包含排序好的输出序列。
算法`INSERTION-SORT`的具体伪代码描述如下：

```
INSERTION-SORT(A){
	for j=2 to A.length
		key = A[j] //选用A[j]作为当前关键字
		//Insert A[j] into the sorted sequence A[1..j-1]
		i=j-1 //前一个位置
		while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key
			A[i+1]=A[i]//后移   //将前一位置的关键字A[i]后移一个位置到A[i+1]
			i=i-1   //继续向前一个位置
		A[i+1] = key //如果前一位置的关键字A[i]小于当前关键字key,将关键字放入前一位置的关键字A[i]的后面A[i+1]		
}
```
该算法的具体描述如下：
>下标j表示正被插入到手中的`当前牌`。
>在for循环（循环变量为j）的每次迭代开始，包含元素$A[1..j-1$的子数组构成当前排序好的左手中的牌，剩余的子数组$A[j+1..n]$对应于仍在桌子上的牌堆。
>事实上，元素$A[1..j-1]$是原来在位置1到$j-1$的元素，但现在已按序排列。
>注：$A[1..j-1]$的如下性质正式地表述为**循环不变式**：
>	在for循环的每次迭代开始时，子数组$A[1..j-1]$由原来在$A[1..j-1]$中的元素组成，但已按序排列。

已经知道，关于**循环不变式**，必须要证明的三条性质：**初始化**——**保持**——**终止**。
现在开始对插入排序的**循环不变式**的三条性质进行证明：
>证明 #0：插入排序的**循环不变式**的性质——**初始化**

证明：在第一次循环迭代之前（当$j=2$时），**循环不变式**成立
子数组$A[1..j-1]$仅由单个元素$A[1]$组成，实际上就是$A[1]$原来的元素。
并且该数组是排序好的。
故在第一次循环迭代之前，**循环不变式**成立

>证明 #0：END

>证明 #1：插入排序的**循环不变式**的性质——**保持**

证明：每次迭代保持**循环不变式**。
非形式化地，for循环体的如下代码：
```
	i=j-1 //前一个位置
	while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key
		A[i+1]=A[i]//后移   //将前一位置的关键字A[i]后移一个位置到A[i+1]
		i=i-1   //继续向前一个位置
```
将$ A[j-1],A[j-2],A[j-3],.. $向右移动一个位置，直到找到$A[j]$的适当位置，执行如下代码：
```
	A[i+1] = key //如果前一位置的关键字A[i]小于当前关键字key,将关键字放入前一位置的关键字A[i]的后面A[i+1]
```
将$A[j]$的值插入该位置。
这时子数组$A[1..j-1]$由原来在$A[1..j-1]$中的元素组成，但已按序排列。
故对for循环的下一次迭代增加j将保持**循环不变式**


>证明 #1：END


>证明 #2：插入排序的**循环不变式**的性质——**终止**

考虑在循环终止时发生什么。
导致for循环终止的条件是$j \gt A.lenghth =n $。
因为 每次循环迭代j增加1，那么必有 $ j=n+1 $。
在**循环不变式**$A[1..j-1]$中，令$ j=n+1 $，有：
子数组$A[1..n]$由原来在$A[1..n]$中的元素组成，但已按序排列。

因为子数组$A[1..n]$就是整个数组，所以整个数组已排序。
故算法正确。

>证明 #2：END


现在，对**插入排序算法**进行分析。
算法`INSERTION-SORT`需要的时间依赖于**输入规模**。
我们知道，排序1000个数的时间 大于 排序3个数的时间。
此外，该算法根据两个输入序列已经排序的程度，对相同**输入规模**的两个输入序列进行排序可能会花费不同的时间。
已经知道：一般来说，算法需要的时间与**输入规模**同步增长，所以程序的运行时间是一个关于输入规模的函数。
要想**插入排序算法**的运行时间，需要分析`INSERTION-SORT`算法的每行代码的时间成本和执行次数。
首先，假设$t_j$表示对于j值执行while循环的次数。
注：当一个for或while循环按通常的方式退出时，执行次数比执行循环体的次数多1。

**表0.`INSERTION-SORT(A)`算法的时间成本和执行次数**

|| ```INSERTION-SORT(A)``` |时间成本|执行次数|
|:--:|-------------------------|:-----:|:----:|
|1|```for j=2 to A.length```|	 $c_1$	| $n$	|
|2|```	key = A[j] //选用A[j]作为当前关键字```|	$c_2$|	$n-1$|
|3|```	//Insert A[j] into the sorted sequence A[1..j-1]```| $0$ |  $n-1$ |
|4|```	i=j-1 //前一个位置```|	$c_4$	|	$n-1$	|
|5|```	while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key``` | $c_5$  | $\displaystyle \sum_{j=2}^n {t_j}$  |
|6|```		A[i+1]=A[i]//后移   //将前一位置的关键字A[i]后移一个位置到A[i+1]```| $c_6$  |  $\displaystyle \sum_{j=2}^n {(t_j-1)}$ |
|7|```		i=i-1   //继续向前一个位置		```| $c_7$  | $\displaystyle \sum_{j=2}^n (t_j-1) $ |
|8|```	A[i+1] = key //如果前一位置的关键字A[i]小于当前关键字key,将关键字放入前一位置的关键字A[i]的后面A[i+1]```|  $c_8$   | 	$n-1$	|

该算法的**运行时间**是执行每条语句的运行时间之和。
需要执行$c_i$步且执行n次的一条语句将贡献$c_i n$给总运行时间。
为计算在具有n个值得输入上，该算法的运行时间$T(n)$，将时间成本与执行次数对应元素之积求和，得：
$$ \displaystyle T(n)= c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {t_j}  + c_6 \sum_{j=2}^n (t_j-1)   +   c_7 \sum_{j=2}^n {(t_j-1)}  + c_8 (n-1)   $$



若输入数组已排好序，则出现**最佳情况**。
这时，对于每个$j=2,3,...,n$，如下代码：
```
	while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key
```
当i取其初值$ j-1 $时，有$ A[i] \le key $，不满足这个while循环的条件，故不执行该while循环体。
从而，对$j=2,3,...,n$，有$t_j=1$。
于是，该算法的**最佳情况**运行时间是：
$$ t_j=1  \\
\displaystyle T(n)= c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {t_j}  + c_6 \sum_{j=2}^n (t_j-1)   +   c_7 \sum_{j=2}^n {(t_j-1)}  + c_8 (n-1)  \\
\displaystyle =  c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {1}  + c_6 \sum_{j=2}^n (1-1)   +   c_7 \sum_{j=2}^n {(1-1)}  + c_8 (n-1)  \\
\displaystyle = c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 (n-1)  +    c_8 (n-1) \\
\displaystyle = c_1 n +  c_2 n - c_2+  c_4 n - c_4  +  c_5 n - c_5  +    c_8 n - c_8  \\
\displaystyle = (c_1+  c_2 +  c_4 +  c_5 +    c_8)n- c_2- c_4 - c_5- c_8  \\
\displaystyle =  (c_1+  c_2 +  c_4 +  c_5 +    c_8)n - (c_2+ c_4 + c_5+ c_8 )   \\
令 a =(c_1+  c_2 +  c_4 +  c_5 +    c_8) , b=- (c_2+ c_4 + c_5+ c_8 ) ,则有：\\
T(n)= a n + b \\
因此，T(n)是一个关于n的线性函数。$$

若输入数组已反向排序，即按递减的顺序排好序，则导致**最坏情况**。
这时，必须将每个元素$A[j]$与整个已排序子数组$A[1..j-1]$中的每个元素进行比较。
所以，对$j=2,3,...,n$，有$t_j=j$，于是有：
$$\displaystyle  \sum_{j=2}^n {t_j} 
\displaystyle =\sum_{j=2}^n {j} 
\displaystyle = {n(n+1)\over 2} -1 \\ 
\displaystyle \sum_{j=2}^n (t_j-1) 
\displaystyle = \sum_{j=2}^n (j-1) 
\displaystyle =  {n(n-1)\over 2}     $$
进一步可得，该算法的**最坏情况**运行时间是
$$\displaystyle 
T(n)= c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {t_j}  + c_6 \sum_{j=2}^n (t_j-1)   +   c_7 \sum_{j=2}^n {(t_j-1)}  + c_8 (n-1)  \\
\displaystyle =  c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 ({n(n+1) \over 2} -1) + c_6 ({n(n-1)\over 2} )+   c_7 ({n(n-1)\over 2} )  + c_8 (n-1)  \\ 
\displaystyle = ({c_5 \over 2}+{c_6\over 2}+{c_7\over 2})n^2 + (c_1+c_2+c_4+{c_5 \over 2} -{c_6\over 2}-{c_7\over 2}+c_8)n - (c_2+c_4+c_5+c_8)   \\
令a= ({c_5 \over 2}+{c_6\over 2}+{c_7\over 2}), b=(c_1+c_2+c_4+{c_5 \over 2} -{c_6\over 2}-{c_7\over 2}+c_8), c= - (c_2+c_4+c_5+c_8)，则有：\\
T(n)=an^2+bn+c  \\
因此，T(n)是一个关于n的二次函数。$$



##### 2. 归并排序

归并排序：为了排序n个项，该算法所花时间大致等于$ {c_2} n \lg n $，其中$ \lg n $代表$ \log_2 n  $，且$ c_2 $是一个不依赖于n的常数。

P17 归并排序
P20 归并排序的分析


**归并排序算法**完全遵循**分治算法**，在每层递归时都有三个子步骤：
* 分解：分解待排序的n个元素的序列成两个分别具有${n \over 2}$个元素的子序列。
* 解决：使用**归并排序**递归地排序两个子序列。
* 合并：合并两个已排序的子序列以产生已排序的答案。

当待排序的序列长度为1时，回归到起点，在这种情况下由于长度为1的每个序列都已排好序，故不需要做任何工作。

**2.1 辅助算法`MERGE(A,p,q,r)`**

**归并排序算法**的关键操作是**合并**步骤中两个已排序序列的合并。
这时，需要一个**辅助算法`MERGE(A,p,q,r)`**完成合并工作，其中A是一个数组，p、q、r是数组下标，且$ p \le q \lt r $。
算法`MERGE(A,p,q,r)`做出了假设：子数组$A[p...q]$和$ A[q+1...r] $都已排好序。
该算法主要的工作是：合并两个子数组$A[p...q]$和$ A[q+1...r] $形成单一的已排好序的子数组并代替当前的子数组$A[p...r]$。

**辅助算法`MERGE(A,p,q,r)`**的具体工作如下：
>回到扑克牌上来，假设桌子上有两堆牌（明牌展示），它们都已排序，第一张牌是最小的。
>我们想要把这两堆牌合并成单一的排好序的输出堆，在桌子上暗牌展示。
>我们的**基本步骤**是：在明牌的两堆牌的首张牌中选取其中较小的一张，将这张牌拿出来，以暗牌方式放到输出堆。
>这样，持续进行这个基本步骤，直到明牌的两堆牌中的其中一堆被取完为止，随后，将剩余的一堆牌放到输出堆。

>注意：因为只是比较明牌的两堆牌的首张牌，所以每个基本步骤需要常量时间。
>并且，因为最多执行$n=r-p+1$（待合并元素的总数）个基本步骤，所以合并需要$\Theta(n)$的时间。

如果用伪代码描述**辅助算法`MERGE(A,p,q,r)`**，需要做一个额外的变化，以避免在每个基本步骤必须检查是否有堆为空，于是在每个堆的底牌放置一张**哨兵**牌，包含一个特殊值（这里选用$ \infty $），用于简化代码。
这样，就可以用伪代码描述该辅助算法了，具体如下：
```
//假设：子数组A[p...q]和A[q+1...r]都已排好序。
//主要的工作是：合并两个子数组A[p...q]和A[q+1...r]形成单一的已排好序的子数组并代替当前的子数组A[p...r]。
MERGE(A,p,q,r){
	n1 = q-p+1  //第一个子数组A[p...q]的大小
	n2 = r-q // 第二个子数组A[q+1...r]的大小
	let L[1..n1+1] and R[1..n2+1] be new arrays // L是A[p...q]+哨兵元素A[n1+1]  R是A[q+1...r]+哨兵元素A[n2+1]
	for i=1 to n1
		L[i]=A[p+i-1]  //将A[p...q]的内容填入L[1..n1+1]
	for j=1 to n2
		R[i]=A[q+j]   //将A[q+1...r]的内容填入R[1..n2+1]
	L[n1+1]= ∞ //L哨兵元素=无穷
	R[n2+1]= ∞ //R哨兵元素=无穷
	i=1
	j=1
	for k=p to r  //从A数组的开头位置p开始 to A数组的尾部位置r  合并的基本步骤
		if L[i] <= R[j]
			A[k]=L[i]  //L[i]最小
			i = i + 1
		else
			A[k]=R[j]  //R[j]最小
			j = j + 1
}
```
**辅助算法`MERGE(A,p,q,r)`**的详细工作过程如下：
>计算子数组$A[p...q]$的长度$n_1$
>计算子数组$A[q+1...r]$的长度$n_2$
>创建长度为$n_1 + 1$和$n_2 + 1$的数组L和R（左和右），每个数组中额外的位置保存哨兵。
>将$A[p...q]$的内容填入$L[1..n1+1]$
>将$A[q+1...r]$的内容填入$R[1..n2+1]$
>将哨兵放在数组L和R的末尾部。
>开始进行合并的基本步骤，循环选出最小并填入A的后半部。

注意，在进行合并的基本步骤，代码如下：
```
	i=1
	j=1
	for k=p to r  //从A数组的开头位置p开始 to A数组的尾部位置r  合并的基本步骤
		if L[i] <= R[j]
			A[k]=L[i]  //L[i]最小
			i = i + 1
		else
			A[k]=R[j]  //R[j]最小
			j = j + 1
```
这时，维持着如下**循环不变式**，执行了$n=r-p+1$个基本操作：
>在开始如上的for循环的每次迭代时，子数组$A[p...k-1]$按从小到大的顺序包含$L[1..n_1+1]$和$R[1..n_2+1]$ 中的$k-p$个最小元素。进而，L[i]和R[j]是各自所在数组中未被复制到数组A的最小元素。


已经知道，关于**循环不变式**，必须要证明的三条性质：**初始化**——**保持**——**终止**。
现在开始对**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的三条性质进行证明，得出如下结论：
>如上for循环的第一次迭代之前以上的**循环不变式**成立，该循环的每次迭代保持这个**循环不变式**，并且循环终止时，这个**循环不变式**提供了一种有用的性质证明了正确性。

具体证明如下：
>证明 #0：**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的性质——**初始化**



>证明 #0：END

>证明 #1：**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的性质——**保持**



>证明 #1：END


>证明 #2：**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的性质——**终止**



>证明 #2：END

现在，对**辅助算法`MERGE(A,p,q,r)`**进行分析。
在**辅助算法`MERGE(A,p,q,r)`**的伪代码中，首先，如下两段代码，它们每行需要常数时间：
```
	n1 = q-p+1  //第一个子数组A[p...q]的大小
	n2 = r-q // 第二个子数组A[q+1...r]的大小
	let L[1..n1+1] and R[1..n2+1] be new arrays // L是A[p...q]+哨兵元素A[n1+1]  R是A[q+1...r]+哨兵元素A[n2+1]
```
```
	L[n1+1]= ∞ //L哨兵元素=无穷
	R[n2+1]= ∞ //R哨兵元素=无穷
	i=1
	j=1
```
然后，如下两个for循环，需要$\Theta(n_1+n_2)=\Theta(n)$的时间
```
	for i=1 to n1
		L[i]=A[p+i-1]  //将A[p...q]的内容填入L[1..n1+1]
	for j=1 to n2
		R[i]=A[q+j]   //将A[q+1...r]的内容填入R[1..n2+1]
```
最后，如下进行合并的基本步骤的for循环有n次迭代，每次迭代需要常量时间：
```
	for k=p to r  //从A数组的开头位置p开始 to A数组的尾部位置r  合并的基本步骤
		if L[i] <= R[j]
			A[k]=L[i]  //L[i]最小
			i = i + 1
		else
			A[k]=R[j]  //R[j]最小
			j = j + 1
```
因此，**辅助算法`MERGE(A,p,q,r)`**的运行时间$ T(n)=\Theta(n) $。

**2.2 归并排序算法`MERGE-SORT(A,p,r)`**

有了**辅助算法`MERGE(A,p,q,r)`**，就可以很容易地写出**归并排序算法`MERGE-SORT(A,p,r)`**。
**归并排序算法`MERGE-SORT(A,p,r)`**的目的是：排序子数组$A[p...r]$中的元素。
若$p \ge r$，则子数组A最多有一个元素，所以已经排好序。
若$p \lt r$，则分解步骤简单地计算一个下标q，将$A[p...r]$分成两个子数组$A[p...q]$和$A[q+1...r]$。
对于子数组$A[p...q]$，包含$\lceil{n\over 2}\rceil$个元素。
对于子数组$A[q+1...r]$，包含$\lfloor{n\over 2}\rfloor$个元素。

如果用伪代码描述**归并排序算法`MERGE-SORT(A,p,r)`**，于是有：
```
//初始调用MERGE-SORT(A,1,A.length)
//A.length=n
MERGE-SORT(A,p,r){
	if p<r
		q = floor((p+r)/2)
		MERGE-SORT(A,p,q)
		MERGE-SORT(A,q+1,r)
		MERGE(A,p,q,r)
}
```
当数组A的长度A.length为$2^k$(k为任意正整数)时，**归并排序算法`MERGE-SORT(A,p,r)`**由以下操作组成：
>合并只含有1项的序列对形成长度为2的排好序的序列，
>合并长度为2的序列对形成长度为4的排好序的序列，
>持续下去，
>直到长度为${n\over 2}$的两个序列被合并最终形成长度为n的排好序的序列。



现在分析**归并排序算法`MERGE-SORT(A,p,r)`**。
虽然**归并排序算法`MERGE-SORT(A,p,r)`**在元素的数量不是偶数时也能正确地工作，但是，如果假定问题规模是$2^k$(k为任意正整数)，那么基于递归式的分析将被简化。
这时，每个分解步骤将产生规模刚好为${n\over 2}$的两个序列。

由于**归并排序算法**完全遵循**分治算法**，因此现在建立n个数的最坏情况运行时间$T(n)$的递归式。
* 当使用**归并排序算法**对一个元素排序时，需要$\Theta(1)$的常数时间。
* 当有$n>1$个元素时，分解运行时间如下：
	* 分解：分解步骤仅仅计算子数组的中间位置，需要常数时间，因此$D(n)=\Theta(1)$。
	* 解决：递归地求解两个规模均为${n\over 2}$的子问题，将贡献$2T({n\over 2})$的运行时间。
	* 合并：在一个具有n个元素的子数组上执行**辅助算法`MERGE(A,p,q,r)`**需要$\Theta(n)$的时间，所以$C(n)=\Theta(n)$。
	* 于是有，当$n>1$时，需要$$ D(n)+2T({n\over 2})+C(n) \\
   =\Theta(1)+2T({n\over 2})+\Theta(n) \\
   =2T({n\over 2})+\Theta(n) $$的时间。

综上所述，**归并排序算法**的最坏情况运行时间$T(n)$的递归式有：
$$ T(n) = \begin{cases}
   \Theta(1) &\text{if } n=1 \\
    2T({n\over 2})+\Theta(n) &\text{if } n \gt 1
\end{cases} $$
这时，需要**主定理**求解这个递归式，并且最终解得$T(n)=\Theta(n \lg n)$。
因为对数函数比任何线性函数增长要慢，所以对于**足够大的输入**，最坏情况运行时间为$\Theta(n \lg n)$的**归并排序算法**将**优于**最坏情况运行时间为$\Theta(n^2)$的**插入排序**。

>Q #0：如何用**递归树**证明$T(n)=\Theta(n \lg n)$？

P21 2.3.2 分析分治算法

>Q #0：END


##### 3. 堆排序
> 参照：“算法之杖”的（二叉）堆


##### 4. 快速排序


**快速排序**遵循**分治算法**思想，它的研究对象是**一个子数组$A[p..r]$**，对这个子数组$A[p..r]$进行如下分治过程：
* **分解**：首先计算划分下标q，在将子数组$A[p..r]$划分为两个可能为空的子数组$A[p..q-1]$和$A[q+1..r]$，使得满足如下条件：$ A[p..q-1]的所有元素 \le A[q] \le A[q+1..r]的所有元素 $。
* **解决**：递归地调用快速排序（这个分治过程），对子数组$A[p..q-1]$和$A[q+1..r]$进行排序。
* **合并**：由于子数组$A[p..r]$都是原址排序，所以不需要合并操作。

为了更好地理解**快速排序**，继续用扑克牌作为例子：
>目前，在桌子上有一摞扑克牌，这摞牌处于无序状态，并且以暗牌（背面朝向上）方式展示。
>将这张桌子划分为**标准点区**、**小号区**、**大号区**、**牌堆区**。
>把这摞无序的牌放到**牌堆区**。
>任务：要将这摞无序的牌进行排序。
>1.首先，从这摞牌中取出第一张牌或最后一张牌，放置到**标准点区**，并称这张牌为**标准牌**。
>2.开始在**牌堆区**中取牌：
>（1） 如果所取得的牌**小于**标准牌，就将这张所取得的牌放到**小号区**。
>（2）如果所取得的牌**大于**标准牌，就将这张所取得的牌放到**大号区**。
>（3）持续进行取牌，直到取完牌堆区的牌。
>这时，得到两堆无序的牌：大号区的牌和小号区的牌。
>接着分别对这两堆牌进行同样的动作。
>最后，就完成了整个排序任务。


###### 4.1.  辅助算法`PARTITION(A,p,r)`
**快速排序**将分解步骤编写为一个**辅助算法`PARTITION(A,p,r)`**。
要想将子数组$A[p..r]$划分为两个可能为空的子数组$A_l$和$A_r$，需要在$A[p..r]$中选用一个**标准点（主元pivot element）**，作为子数组$A_l$和$A_r$的界线。
在选好**标准点（主元pivot element）**之后，

至于如何在$A[p..r]$中选用这个**标准点（主元pivot element）**，有许多不同的方案。这些方案都影响着**辅助算法`PARTITION(A,p,r)`**的执行时间。
通常，选用$A[p..r]$的首元素或尾元素作为**标准点（主元pivot element）**。
1.选用$A[p..r]$的**首元素$A[p]$**作为**标准点（主元pivot element）**

当**首元素$A[p]$**作为标准点时，**辅助算法`PARTITION(A,p,r)`**的伪代码描述如下：
```
PARTITION(A,p,r){

}
```

2.选用$A[p..r]$的**尾元素$A[r]$**作为**标准点（主元pivot element）**

当**尾元素$A[r]$**作为标准点时，**辅助算法`PARTITION(A,p,r)`**的伪代码描述如下：
```
PARTITION(A,p,r){
	x=A[r] //选择尾元素A[r]作为标准点，放在标准点区
	i=p-1 //数组A_l的循环变量i，它始终指向小号区的最后一个元素
	for j=p to r-1   //在牌堆逐一取牌
		if A[j]<= x  //选出小号区的牌
			i=i+1
			exchange A[i] with A[j] //将所取得的牌放到小号区
		//这里，大号区与牌堆区合并，
		//属于大号区的牌继续在牌堆区
	exchange A[i+1] with A[r] //将标准点放到小号区和大号区（牌堆区）的中间。
}
```
在**辅助算法`PARTITION(A,p,r)`**中，for循环的每一轮迭代的开始，标准点区、大号区、小号区、牌堆区都满足如下性质，这些性质就是**循环不变式**：
>for循环的每一次迭代开始时，对于任意数组下标k，有：
>1.若$p \le k \le i$，则$A[k] \le x$.
>2.若$i+1 \le k \le j-1$，则$A[k]  \gt x$。
>3.若$k=r$，则$A[k]=x$。

该**循环不变式**的具体证明如下：
>证明 #0：**辅助算法`PARTITION(A,p,r)`**中的**循环不变式**的性质——**初始化**



>证明 #0：END

>证明 #1：**辅助算法`PARTITION(A,p,r)`**中的**循环不变式**的性质——**保持**



>证明 #1：END


>证明 #2：**辅助算法`PARTITION(A,p,r)`**中的**循环不变式**的性质——**终止**



>证明 #2：END


**辅助算法`PARTITION(A,p,r)`**在子数组$A[p..r]$上的时间复杂度是$\Theta(n=r-p+1)$。


###### 4.2.  算法`QUICKSORT(A,p,r)`

在辅助算法`PARTITION(A,p,r)`的基础上用伪代码描述算法`QUICKSORT(A,p,r)`，则有：
```
//为了排序一个数组A的全部元素，初始调用是QUICKSORT(A,1,A.length)
QUICKSORT(A,p,r){
	if p<r
		q=PARTITION(A,p,r)
		QUICKSORT(A,p,q-1)
		QUICKSORT(A,q+1,r)
}
```

现在，对**快速排序**进行非形式化地分析：
**快速排序**的运行时间依赖于划分是否平衡，而平衡又依赖于用于划分的元素。
如果划分是平衡的，那么**快速排序**的性能与归并排序一样，即$\Theta(n \lg n)$。
如果划分是不平衡的，那么**快速排序**的性能就接近于插入排序的性能，即$\Theta(n^2)$。
（1）最坏情况的划分
在最坏情况下，划分产生两个子问题是n-1个元素和0个元素。
假设：算法`QUICKSORT(A,p,r)`的每一次递归都出现这样的划分。
划分操作的时间复杂度是$\Theta(n)$。
对于0个元素的数组，它的时间复杂度是$\Theta(1)$
于是，算法`QUICKSORT(A,p,r)`的运行时间的递归式为：
$$ T(n)=T(n-1)+T(0)+\Theta(n) \\
=T(n-1)+\Theta(n)$$
利用**代入法**求得该递归式：
$$ T(n)=T(n-1)+\Theta(n) \\
=\Theta(n^2)$$

在最坏情况下，**快速排序**的运行时间并不比插入排序更好。
如果输入数组是有序的，**快速排序**的最坏情况运行时间依然是$\Theta(n^2)$。
反观插入排序，在输入数组是有序的时，插入排序的最坏情况运行时间却是$\Theta(n)$

（2）最好情况的划分
在可能的最平衡的划分中，所划分的两个子问题都是不大于${n\over 2}$个元素的数组：
* 一个$\lfloor {n\over 2}\rfloor$个元素的数组
* 一个$\lceil {n\over 2}\rceil -1 $个元素的数组

这种情况下的**快速排序**的性能非常好，算法`QUICKSORT(A,p,r)`的运行时间的递归式为（忽略了一些余项和常数项）：
$$ T(n)=2 T({n\over 2}) + \Theta(n) $$
根据**主定理**的CASE 2，求得该递归式的解为$T(n)=\Theta(n \lg n)$


###### 4.3.  随机化算法`RANDOMIZED-QUICKSORT(A,p,r)`

```
RANDOMIZED-PARTITION(A,p,r){
	i=RANDOM(p,r)
	exchange A[r] with A[i]
	return PARTITION(A,p,r)
}
```
...
```
RANDOMIZED-QUICKSORT(A,p,r){
	if p<r
		q=RANDOMIZED-PARTITION(A,p,r)
		RANDOMIZED-QUICKSORT(A,p,q-1)
		RANDOMIZED-QUICKSORT(A,q+1,r)
}
```
...
###### 4.4. **快速排序**的分析

现在，对**快速排序**进行形式化地分析：

...





#### `比较`排序算法的总结

在以上这些能在$O(n \lg n)$时间内排序n个数的算法中，**归并排序**和**堆排序**达到了最坏情况下的上界，**快速排序**在平均情况下达到$O(n \lg n)$的上界。
而且，对于这些算法的每一个，给定n个输入数值，都能在$\Omega(n \lg n)$时间内完成。

下面将要证明：
> 证明：$$ 在最坏情况下，任何比较排序算法都需要做\Omega(n \lg n)次比较。 $$

**已知**：在比较排序算法中，只使用元素间的比较获得输入序列$< a_1,a_2,...,a_n >$中的元素间次序的信息。
这表明，给定两个元素$a_i$和$a_j$，可以执行$a_i \lt a_j , a_i \le a_j , a_i = a_j , a_i \ge a_j , a_i \gt a_j$中的一个比较操作确定它们之间的相对次序。
**假设**：所有的输入元素都是互异的。
这时，$a_i = a_j $就被舍去，$ a_i \lt a_j $等价于$a_i \le a_j$，$a_i \gt a_j$等价于$a_i \ge a_j $。
进一步**假设**：所有比较采用的都是$a_i \le a_j$。

首先，将**比较排序**抽象为一棵**决策树**。
对于**决策树**，它是一棵完全二叉树，用于表示**在给定输入规模下，某一特定排序算法对所有元素的比较操作**。
注意：**决策树**忽略了~~控制~~,~~数据移动~~等其他操作。

在**决策树**中，每个内部结点都以$< i : j >$（$1\le i，j \le n且n是输入序列中的元素个数 $）标记，每个叶子节点上都标注一个序列$< \pi(1),\pi(2),...,\pi(n) >$。
排序算法的执行对应于一条从树的根结点到叶子结点的路径。
每个内部结点表示一次比较（$a_i \le a_j$）。
左子树表示一旦确定$a_i \le a_j$之后的后续比较。
右子树表示一旦确定$a_i \gt a_j$之后的后续比较。
当到达一个叶子结点时，表示排序算法已经完成排序并得到序列$ \pi(1) \le  \pi(2) \le ... \le \pi(n) $。
因为任何正确的排序算法都能够生成输入的每一个排列，所以：
对于一个正确的比较排序算法来说，n个元素的$n!$种可能的排列都应该出现在决策树的叶子结点上，并且，每一个叶子结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程。
因此，**假设**：每一种排列都是一个可达的叶子结点的决策树。

在**决策树**中，从根结点到任意一个可达叶子节点之间最长简单路径的长度，对应于排序算法中最坏情况下的比较次数。
因此，一个比较排序算法中的最坏情况比较次数就是**其决策树的高度**。
于是，当决策树中每种排列都是以可达的叶子结点的形式出现时，该决策树高度的下界就是比较排序算法运行时间的下界。

现在考虑一棵高度为h、具有l个可达叶子结点的决策树，它对应一个对n个元素所做的比较排序。
因为输入数据的$n!$种可能的排列都是叶子结点，所以有：
$$ n! \le l $$
由于在一棵高为h的二叉树中，叶子结点的数目$\le 2^h$，因此有：
$$ n! \le l  \le 2^h$$
对该不等式两边取对数，有：
$$ h \ge \lg(n!) \\
=\Theta(n \lg n)
= \Omega(n \lg n) $$

> 证明：END

> 推论：堆排序和归并排序都是渐近最优的比较排序算法。

堆排序和归并排序的运行时间的上界为$O(n \lg n)$ 与 最坏情况下的下界$\Omega(n \lg n) $一致。

> 推论：END

#### `其他`排序算法

##### 1. 计数排序

**计数排序**假设n个输入元素中的每一个都是在0到k区间的一个整数，其中k为某个整数。
当$k=O(n) $时，**计数排序**的运行时间是$\Theta(n)$。

**计数排序**的基本思想是：对每一个输入元素x，确定小于x的元素个数。这样，就可以把x放到它在输出数组中的位置上。当有几个元素相同时，由于不能把它们放在同一位置上，所以需要对**计数排序**进行稍作改进。

**计数排序**的具体描述：
>现在有一个包含8个元素的输入数组$A=\{2,5,3,0,2,3,0,3\}$，给定一个同样包含8个元素的输出数组$B=\{0,0,0,0,0,0,0,0\}$。
>由于数组A的最大值是5，故数字的范围是$0..5$。
>现在进行**统计每个数字出现的次数**：

$$2个数字0 \\
0个数字1 \\
2个数字2 \\
3个数字3 \\
0个数字4 \\
1个数字5$$

>出现了5个数字。
>如果按顺序排序，可得统计结果如下表格：

| 0   |  1  |   2  |   3  |  4  |  5  |
|:-----:|:-----:|:------:|:------:|:-----:|:------:|
| 0,0 |     |  2,2 | 3,3,3 |    |   5   |
|	2  |  0  |   2   |   3   | 0   |  1   |

>由于数组A存在重复元素，要想把排序的结果填入到数组B，为了避免填入在同一位置，需要**提前计算每个数字出现在数组B的最大位置**。
>至于如何计算每个数字出现在数组B的最大位置，假设我们想要知道**数字3出现在数组B的最大位置**，已经知道数字3在数组A的个数是3，它就是数字3在数组B的所占的空间，即3个位置。
>但是数字3在数组B的所占的空间的具体位置（起始位置）在哪里？
>我们知道，数字3的前面还有数字0、数字1和数字2。
>于是就能确定：数字3在数组B的所占的空间的具体位置（起始位置）就是数字0、数字1和数字2的总空间，即：
>$$在数组B中，数字3的具体位置=数字0所占的空间+数字1所占的空间+数字2所占的空间$$
>所以，就得到了**数字3出现在数组B的最大位置**，即：
>$$在数组B中，数字3的最大位置 = 数字3所占的空间 + 数字3的具体位置\\
>= 数字3所占的空间 + (数字0所占的空间+数字1所占的空间+数字2所占的空间)$$
>同理，从数字0到数字5，它们的最大位置有：

$$\\
数字0的最大位置  = 数字0所占的空间  \\
数字1的最大位置  = 数字1所占的空间 + 数字0所占的空间   \\
= 数字1所占的空间 + 数字0的最大位置
数字2的最大位置  = 数字2所占的空间 + (数字1所占的空间 + 数字0所占的空间) \\
= 数字2所占的空间 + (数字1所占的空间 + 数字0的最大位置)\\
= 数字2所占的空间 + 数字1的最大位置$$

>综上所述，就得到了**每个数字出现在数组B的最大位置**，即：

$$在数组B中， 数字i的最大位置 = 数字i所占的空间 + 数字(i-1)的最大位置 $$

>现在，对统计结果进行全新的改动：

|数字i| 0   |  1  |   2  |   3  |  4  |  5  |
|-|:-----:|:-----:|:------:|:------:|:-----:|:------:|
|排序结果| 0,0 |     |  2,2 | 3,3,3 |    |   5   |
|出现次数|	2  |  0  |   2   |   3   | 0   |  1   |
| 最大位置|  2 |  2  |   4   |   7   |   7 |  8   |

>由于将排序结果填入到数组B不仅需要数字的最大位置，还需要数字的每一个位置，故需要在填入过程中，先填入数组，再对数字的最大位置进行递减，使得下一次填入的使用。
>现在考虑**如何填入到数组B**，首先要从数组A中拿到数字i，然后根据数字i获得该数字在数组B的位置，接着填入到数组B。
>这样，就可以得到数组$B=\{0,0,2,2,3,3,3,5\}$。




算法`COUNTING-SORT(A,B,k)`的伪代码描述如下：
```
//输入是一个数组A[1..n],A.length=n
//输出是一个数组B[1..n]存放排序的输出
//临时数组C[0..k]提供临时存储空间
COUNTING-SORT(A,B,k){
	let C[0..k] be a new array
	for i=0 to k  //初始化C[0..k]  i=k
		C[i]=0
	for j=1 to A.length  //遍历数组A，
		C[A[j]]=C[A[j]]+1  //对数组A的每一个元素进行统计每个数字出现的次数，结果存放在数组C
	//C[i] now contains the number of elements equal to i
	for i=1 to k    //统计每个数字（下标）在数组B的最大位置
		C[i]=C[i]+C[i-1]
	//C[i] now contains the number of elements less than or equal to i
	for j=A.length downto 1
		B[C[A[j]]]=A[j]		//填入数组B：从数组A中拿到数字i，然后根据数字i获得该数字在数组B的位置，接着填入到数组B。
		C[A[j]]=C[A[j]]-1  //获得数字的前一个位置
}
```

考虑**计数排序**的运行时间，第一个for循环需要$\Theta(k)$，第二个循环需要$\Theta(n)$，第三个循环需要$\Theta(k)$，第四个for循环需要$\Theta(n)$，所以，**计数排序**的运行时间是$\Theta(k+n)$。
在实际工作中，当$k=O(n)$时，一般采用**计数排序**，因为这时的运行时间是$\Theta(n)$。
**计数排序**是使用输入元素的实际值确定其在数组上的位置，因此**计数排序**的下界要优于$\Omega(n\lg n)$。

由于**计数排序**具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同，因此，它是稳定的。
这表明，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。
但只有当进行排序的数据还附带卫星数据时才能体现**计数排序**的稳定性。
此外，由于**计数排序**的稳定性，它经常被用作**基数排序**的辅助算法。


##### 2. 基数排序

**基数排序（radix sort）**是一种用在卡片排序机上的算法。
一张卡片有80列，在每一列上机器可以选择在12个位置中的任一处穿孔。
通过机械操作，可以对排序机“编程”，从而检查每个卡片中的给定列，然后根据穿孔的位置将它们分别放入12个容器中。
接着，操作员就可以逐个地从容器收集卡片。
对于十进制数字来说，每列只会用到10个位置，其他两个位置用于编码非数值字符。
一个d位数占用d列。
因为卡片排序机一次只能查看一列，所以：
要对n张卡片上的d位数进行排序，就需要设计一个排序算法。

**基数排序（radix sort）**首先按**最低有效位**进行排序，然后将所有卡片合并在一叠。
之后，用同样的方法按**次低有效位**对所有卡片进行排序。
重复这一过程，直到对所有的d位数字都进行排序。
最后，所有卡片已按d位数完全排好序。
所以，对这一叠卡片的排序仅需要进行d轮。

为了确保**基数排序**的正确性，一位数排序算法必须是稳定的。
卡片排序机所执行的排序是稳定的，但操作员必须确保卡片从容器中被取出时不改变顺序，即使一个容器中的所有卡片在该位都是相同的数字也要确保稳定。

在一台典型的串行随机存取计算机（RAM模型）中，有时会用**基数排序**对具有多关键字域的记录进行排序。
>例如，用三个关键字（年、月、日）对日期进行排序。
>一般做法是：使用基于特殊比较函数的排序算法，先比较年，如果相同，再比较月，如果相同，就比较日。
>特殊做法是：使用一种稳定排序算法对这些信息进行三次排序，即日---月---年。

下面是算法`RADIX-SORT(A,d)`的伪代码描述：
```
RADIX-SORT(A,d){
	for i=1 to d
		use a stable sort to sort array A on digit i  //使用计数排序算法
}
```

>引理 0：给定n个d位数，其中每一个数位有k个可能的取值。如果`RADIX-SORT(A,d)`使用的稳定排序方法需要$\Theta(n+k)$时间，那么它就可以在$\Theta(d(n+k) )$时间内将这些数排好序。
>引理 0：END

当d为常数且$k=O(n)$时，**基数排序**具有线性时间。
在更一般的情况下，可以灵活地决定如何将每个关键字分解成若干位。

>引理 1：给定一个b位数和任何正整数$r \le b$，如果`RADIX-SORT(A,d)`使用的稳定排序算法对数据取值区间是0到k的输入进行排序需要$\Theta(n+k)$时间，那么它就可以在$\Theta( ({b\over r}) (n+2^r)  )$的时间内将这些数排好序。
>引理 1：END

>Q #0 : **基数排序**是否比基于比较的排序算法更好呢？
>Q #0：END


##### 3. 桶排序

**桶排序（bucket sort）**假设输入数据服从均匀分布，平均情况下它的运行时间是$O(n)$。

**桶排序（bucket sort）**假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在$[0,1)$区间上。

**桶排序（bucket sort）**将$[0,1)$区间划分为n个相同大小的子区间（桶），然后，将n个输入数分别放到各个桶中，因为输入数据是均匀、独立地分布在$[0,1)$区间上，所以一般不会出现很多数落在同一个桶中的情况，为了得到输出结果，**先对每个桶中的数进行排序，然后遍历每个桶，按次序把各个桶中的元素列出来即可**。

下面是算法`BUCKET-SORT(A)`的伪代码描述：
```
//输入：一个包含n个元素的数组A，且每个元素A[i]满足[0,1)区间。
//一个临时数组B[0..n-1],用于存放链表（桶）
//假设：存在一种用于维护链表的机制。
BUCKET-SORT(A){
	n =A.length
	let B[0..n-1] be a new array
	for i=0 to n-1
		make B[i] an empty list
	for i=1 to n
		insert A[i] into B[floor(n*A[i])]
	for i=0 to n-1
		sort list B[i] with insertion sort
	concatenate the lists B[0],B[1],..B[n-1] together in order
}
```

验证算法的正确性

...


分析桶排序的运行时间


...


************