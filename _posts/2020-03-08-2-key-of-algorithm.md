---
title: "2.\"算法之钥\""
tags: AlgorithmBox
---

## “算法之钥”

### 算法


#### 1. 认识算法

> Qs：{
> 	#0.什么是算法？
> 	#1.为什么算法值得研究？
> 	#2.相对于计算机中使用的其他技术来说算法的作用是什么？
> }
<!--more-->
>Q #0：什么是算法？

非正式地说，**算法（algorithm）** 就是任何良（明确）定义的计算过程，该过程取某个值或值的集合作为**输入**并产生某个值或值的集合作为**输出**。
也就是说，**算法**就是把**输入**转换成**输出**的计算步骤的一个序列。
或者说，**算法**是用于求解良（明确）规定的**计算问题**工具。
问题的陈述一般指定了所需的 _输入_/_输出_ 关系。
由此，**算法** 描述了一个特定的计算过程，用于实现这种 _输入_/_输出_ 关系

如果**算法**在每个 **输入** 实例上都以正确的输出结束，那么这样的算法是**正确**的，并认为这个正确的算法解决了给定的计算问题。
反之，不正确的算法对某些输入实例可能根本不结束，也可能以不正确的输出结束。
但在少数情况下，这种不正确的算法只要具备**可控的错误率**也被认为是“正确”的。
注：我们只关心正确的算法。

**算法** 可以用**自然语言（如英语）**描述**计算机程序**或**硬件设计**。
注：必须精确地描述所要遵循的计算过程。



>Q #1.为什么算法值得研究？

算法的实际应用有很多，如下：
* `人类基因工程`：识别人类DNA中的所有10万个基因，确定构成人类DNA的30亿个化学基对的序列，在数据库中存储这类信息并为数据分析开发工具。
* `搜索引擎`：互联网使得全世界的人能够快速地访问与检索大量信息，使用搜索引擎快速地找到特定信息所在的网友。
* `电子商务`：它使得货物与服务能够以电子方式洽谈与交换，并且它依赖于个人信息（如信用卡号、密码和银行账单等）的保密性，必须使用**公钥密码**与**数字签名**这种核心技术，而这种技术是以**数值算法**和**数论**为基础的。
* `资源分配`：制造业和其他商务企业常常需要按**最有益的方式**分配**稀有资源**，例如：
	* 石油公司希望知道在什么地方设置油井，以便最大化预期的利润；
	* 政治候选人想确定在什么地方花钱购买竞选广告，以便最大化赢得竞选的机会；
	* 航空公司希望按尽可能最廉价的方式把乘务员分配到班机上，以确保每个航班被覆盖并且满足政府有关乘务员调度的法规；
	* 互联网服务提供商希望确定在什么地方放置附加的资源，以便更有效地服务其顾客。
以上类似的例子都可以用**线性规划**求解。

更具体一些，**算法**能够解决如下的具体问题：
* `确定最短道路`：给定一张交通图，图上标记有每对相邻十字路口之间的距离，如何确定从一个十字路口到另一个十字路口的**最短道路**。如果不允许穿过自身的道路，可能的路线会有多少？在所有的可能路线中，如何选择一条最短的？大体的解决方案如下：
	* 1.把交通图建模为一个图，
	* 2.寻找图中从一个顶点到另一个顶点的最短路径。
* `两条符号序列的最长公共子序列`：给定两个有序的符号序列$X=< x_1,x_2,...,x_m >$和$Y=< y_1,y_2,...,y_n >$，求出$X$和$Y$的**最长公共子序列**。若$X$有m个符号且$Y$有n个符号，则$X$和$Y$分别有$ 2^m $和$ 2^n $个可能的子序列。如果m和n很大，那么选择$X$和$Y$的所有可能子序列做匹配将花费昂贵的时间。可以使用**动态规划**技术有效地求解该问题。
* `拓扑排序`：给定一个依据部件库的机械设计，其中每个部件可能包含其他部件的实例，需要依次列出这些部件，以使每个部件出现在使用它的任何部件之前。若该设计由n个部件组成，则存在$n!$这可能的顺序。因为**阶乘函数**甚至比**指数函数**增长还快，如果部件数量很大，就不能~~先列出每种可能的顺序，再验证每种顺序是否可行~~。可以使用**拓扑排序**技术有效求解该问题。
* `寻找凸壳`：给定平面上的n个点，寻找这些点的**凸壳**。`凸壳`是包含这些点的最小的凸多边形。

综合来看，大多数有趣的算法问题具有两个特征：
* 存在许多**候选解**，但绝大多数**候选解**都没有解决手头的问题。
	* 寻找一个真正的解或最好的解可能是一个很大的挑战。
* 存在**实际应用**。
	* 如**最短路径**的问题。

但要注意：**算法解决的每个问题并不都有一个容易识别的候选解集**。

**建议**：$ 有关算法的书 = 一本“菜谱” $ 

如果某天遇到一个问题，不能用一个已有的算法解决它，那么可以使用一些**算法设计与分析**的技术去进行如下环节：
* 设计新的算法
* 证明该算法的正确性
* 理解该算法的效率（算法的速度：算法花多长时间产生结果）

但是仍然存在一些问题并没有有效的解法，这类问题的一个子集被称为**NP完全性**
**NP完全问题**的有趣点：
* 虽然没有有效的解法，但无法证明**NP完全问题**不存在有效的解法。
* **NP完全问题集**具有一个非凡的性质：
	* 如果任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法
* 有几个**NP完全问题**类似于一些有已知有效算法的问题。

有些**NP完全问题**能够在实际应用中反映出来。
与其花费许多时间去寻找某一个NP完全问题的有效算法，还不如证明该问题是**NP完全性**，如果证明成立，那么可以开发一个有效的“近似“算法。

多核计算机解决了单核计算机的重大问题：由于功率密度随时钟速度**超线性**地增加，一旦时钟速度变得足够快，CPU将**有熔化的危险**。
**建议**：$ 多核计算机 \approx 多台顺序执行的单核计算机 $
多核计算机是一类”并行计算机“。
为了从多核计算机获得最佳的性能，设计算法时必须考虑**并行性**，建立**多核的”多线程“算法**模型。


>Q #2.相对于计算机中使用的其他技术来说算法的作用是什么？

**假设**：计算机是无限快的并且计算机存储器是免费的。
在这种场景下求解问题时，即便在好的软件工程实践的范围内求解该问题，最终都会选择最容易实现的算法。

但事实是：**计算机并不是无限快的，存储器也不是免费的**。
计算时间是一种有限资源，存储器中的空间也是一种有限资源。
因此我们需要**通过有效的算法合理地使用这些资源**。

在有限的资源下，同一问题的不同算法在效率方面通常具有显著的差别。

我们应该把**算法**看作是一种**技术**。
整个系统的性能不但依赖于**选择快速的硬件**，而且还依赖于**选择有效的算法**。

在其他先进的计算机技术中，都或多或少地使用着**算法技术**。
算法是当代计算机中使用的大多数技术的核心。
”**Having a solid base of algorithmic knowledge and technique** is one characteristic that separates the truly skilled programmers from the novices.“
使用现代计算技术，如果你对算法懂得不多，你也可以完成一些任务。
但是，如果你有一个好的算法背景，那么你可以做的事情就多得多。


#### 2. 算法设计与分析的框架

> 《算法导论》2、3、4、5章

**算法**可以描述为**伪代码**的程序。
**伪代码**的优点

* 伪代码可以使用最清晰、最简洁的表示方法说明给定的算法。
* 伪代码不关心软件工程的问题。
	* 为了更简洁地表达算法的本质，常常忽略~~数据抽象、模块性和错误处理的问题~~。

**伪代码**的规则 

* $ 缩进 = 块结构 $，可大大提高代码的清晰性。
* 使用`while`,`for`,`repeat-until`,...循环和使用`if-else`,...条件结构;
	* **退出循环后，循环计数器保留先前值**；
	* $ to = 递增循环计数器 $
	* $ downto = 递减循环计数器 $
	* $ by = 递增（减）量 $
* 使用`//`注释
* $ i=j=e $ 等价于：
	* $ j=e $，$ i=j $
* 如果没有指定说明，一般使用`局部变量`
* 使用`数组名[下标]`访问数组元素
* $ 复合数据 = 对象 $，$ 一个数组或对象的变量 = 指向表示数组或对象的数据的一个指针  $，属性记号`.`允许`串联`，$ 空指针 = NIL $
* 过程的参数是`按值传递`（参数的副本）的；对象传递时，仅复制指向对象数据的指针，不进行`深复制`；数组传递时，仅传递指向数组的指针。
* 单一的`return`语句可以返回多个值。
* 布尔运算符`and`和`or`都是`短路`的。
* `error`表示一个错误，调用过程负责处理该错误。



> Q #0：如何证明算法的正确性？

为了**证明算法的正确性**，可以使用**循环不变式（ loop invariant）**。

`循环不变式（ loop invariant）`的三条性质

* `初始化（Initialization）`: 在循环的第一次迭代之前是正确的。
* `保持（Maintenance）`: 如果在循环的迭代之前为真，则在下一个迭代之前仍为真。
* `终止（Termination）`: 当循环终止时，不变式为我们提供了一个有用的属性，帮助我们证明算法是正确的。

注：以上三条性质都需要证明。

当`初始化（Initialization）`和`保持（Maintenance）`成立时，在循环的每次迭代之前**循环不变式（ loop invariant）**为真。
它们的证明 $ \approx $ 数学归纳法 ，即：
* 数学归纳法： 为了证明某条性质成立，需要证明一个基本情况和一个归纳步。
* `初始化（Initialization）`和`保持（Maintenance）`的证明方法：
	*  “基本情况”：证明第一次迭代之前**循环不变式（ loop invariant）**成立
	*  “归纳步”：证明从一次迭代到下一次迭代**循环不变式（ loop invariant）**成立

对于`终止（Termination）`的证明方法，可以将**循环不变式（ loop invariant）**与**循环终止条件**相结合，证明算法的正确性。
注：`终止（Termination）`的证明方法 $ \not \approx $ 数学归纳法，因为：
* 数学归纳法：其中的归纳步是无限使用的
* `终止（Termination）`的证明方法：当循环终止时，停止“归纳步”。

`循环不变式（ loop invariant）`的应用：略！


##### 2.1. 算法分析

######　2.1.1 机器模型

在算法分析中，需要一种**机器模型**作为对真实计算机的抽象。
这种**机器模型**包含有特定技术和成本的资源模型。

这里的**机器模型**是一种通用的**单核**且具有**随机访问**的机器，被称为**RAM模型**。
>注：不能滥用**RAM模型**！
>建议：真实计算机如何设计，**RAM模型**就如何设计。

在**RAM模型**中，指令是顺序执行的。
这个**RAM模型**是并没有精确地定义各个方面（指令和成本）。

在**RAM模型**中，包含有真实计算机中常用的指令（所有指令都需要`常量时间`）：
* `算术指令`：$ +, -, \times, \div, \%,  \lceil \rceil , \lfloor \rfloor $
* `数据移动指令`：$ 装入，存储，复制 $
* `控制指令`： $ 条件转移，无条件转移，子程序调用，子程序返回 $
* `灰色区域`：其他特定的指令 -----**应尽量避免使用这些指令**

在**RAM模型**中，数据类型有：
* `整数型`
* `浮点实数型`

在**RAM模型**中，并没有对真实计算机的内存层次进行建模，故不存在**内存模型**。




######　2.1.2 基于`RAM模型`的`算法分析`


**算法分析**的目的是预测`当前算法`所需的资源（内存、通信带宽、计算机硬件等）。
但主要注重的是**计算时间**的度量。

通常一个问题存在多种**候选算法**，通过对这些**候选算法**的分析，选出一种**最优的算法**。

采用**RAM模型**分析算法是一个挑战，因为不仅需要洞察能力，还需要很多的数学工具，如：
* 组合学
* 概率论
* 代数


因为 对每个可能的输入有不同的算法行为，所以 需要**一种方法**可以用**简单的、易于理解的公式**的形式总结算法的各种行为。简单地说，这种方法的所要解决的问题是：**如何表达特定算法的分析结果**。

>Q #0：如何表达特定算法的分析结果？

一般来说，算法需要的时间与输入的规模同步增长，所以通常把**一个算法的运行时间**描述为**一个关于输入规模的函数**。这里，存在两个术语：
* **输入规模**：`输入规模`依赖于所要研究的问题，对于研究的每个问题，需指出所使用的输入规模量度。
* **运行时间**：一个算法在特定输入上的`运行时间`是执行的基本操作数或步数，这时，可以使用这样的`观点`:**执行每行伪代码需要常量时间**，
	* 也就是说，虽然一行与另一行可能需要不同数量的时间，但可以假定$ 第i行的每次执行需要的时间是c_i,其中c_i是一个常量 $。

这样，一个算法的**运行时间**最初是**使用所有语句的含$ c_i $的表达式**，经过代数化简后最终得到是**一个更加简明、更容易处理的最简式**。

算法的**运行时间**通常存在三种情况：
* 最坏运行时间：由最坏的输入规模产生
* 平均运行时间：由给定规模的所有输入的平均值产生 or 由**随机算法**产生的随机输入产生的**期望运行时间**作为平均运行时间
* 最好运行时间：由最好的输入规模产生

基于`RAM模型`的`算法分析`主要集中于只求**最坏运行时间**，即对规模为n的任何输入，算法的最长时间。

> Q #0.1 为什么要集中于只求**最坏运行时间**？

其理由如下：
* 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个**上界**。
* 对于某些算法，最坏情况经常出现。
* 大多时候，平均运行时间会倾向于最坏情况。

> Q #0.1 End

已经知道：**一个算法的运行时间**就是**一个自变量为输入规模的函数**。
可以进行抽象，由于一种函数表明了一种变化趋势，可以从该变化趋势得出函数的**变化率**或**变化速度**，反映到算法的**运行时间**上，就有了**增长率**或**增长量级（Order of growth）**的概念。
并且，由于当**输入规模**很大时，该函数的低阶项和常数项变得不那么重要，故运行时间的**增长量级**主要考虑函数的高阶项。

如果一个算法的最坏情况运行时间具有更低的**增长量级**，那么这个算法就是有效的。
在较小的输入规模下，由于低阶项和常数项的存在，使得运行时间具有较高**增长量级**的算法是有效的。
但在足够大的输入规模下，运行时间具有较低**增长量级**的算法是有效的。



当输入规模足够大到只有运行时间的**增长量级（Order of growth）**时，我们要研究算法的**渐近**效率。
在研究算法的**渐近**效率的过程中，我们所关心的是：**当输入规模无限增加至某个极限值时，算法的运行时间如何随着输入规模的变大而增加**，最终得到一个满足除了很小的输入外的所有情况的渐近地更有效的算法。
并且，可以使用几种标准方法简化算法的**渐近分析**：
* 渐近记号：
	* $ \Theta $
	* $ O 与 \omicron $
	* $  \Omega 与 \omega   $
	* 等式和不等式中的渐近记号
* 标准记号与常用函数
	* 单调性
	* $ \lfloor   \rfloor $ 与 $ \lceil   \rceil $
	* 模运算
	* 多项式
	* 指数
	* 对数
	* 阶乘
	* 多重函数
	* 多重对数函数
	* 斐波那契数


在对一个算法的平均情况分析的过程，需要使用**概率分析技术**得出**随机算法**，这个算法做出一些随机的选择，以允许进行概率分析，从而产生**期望的运行时间**来作为平均运行时间。
> 第5章 概率分析和随机算法



....




##### 2.2.算法设计

可以选择使用的**算法设计技术**有很多。

###### 2.2.1 分治算法（Divide-and-Conquer）
> 2.3.1-2.3.2 分治策略  Divide-and-Conquer

**递归型算法**的思想是：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。
这种递归型算法遵循**分治算法（Divide-and-Conquer）**的思想：将原问题**分解**为几个规模较小但类似于原问题的子问题，递归地**求解**这些子问题，然后再**合并**这些子问题的解，从而得到原问题的解。对其思想进行拆解可得：
* **分解**原问题为若干子问题，它们是原问题的规模较小的实例。
* **解决**这些子问题，递归地求解各子问题。**若子问题的规模足够小，则可直接求解**。
* **合并**这些子问题的解成原问题的解。

对于**递归型算法**和**分治算法（Divide-and-Conquer）**，我们都可以用**递归方程（递归式）**描述它们的运行时间，该方程根据在较小输入上的运行时间，描述在输入规模为n的问题上的总运行时间，然后使用**数学工具**求解该方程，从而给出这些算法的性能上的界。
对于**分治算法（Divide-and-Conquer）**，它的运行时间的**递归方程（递归式）**依赖于它的思想。
具体地说，假设$ T(n) $ 是规模为n的一个问题的运行时间。
若问题的输入规模的最大值为常量c，即$ n \le c  $，则直接求解得出需要$O(1)$的常数时间。
假设把原问题分解为a个子问题，每个子问题的输入规模是原问题的$ {1 \over b} $。
为了求解一个输入规模为$ {n \over b} $的子问题，需要$ T({n \over b}) $的时间，所以需要$ aT({n \over b}) $的时间可求解a个子问题。
如果分解问题成子问题的时间是$ D(n) $ ，合并子问题的解成原问题的解的时间是$ C(n) $ ，那么可以得到如下的**递归方程（递归式）**：
$$ T(n) = \begin{cases}
   \Theta(1) &\text{if } n \le c \\
   a T({n \over b}) + D(n) +  C(n) &\text{其他} 
\end{cases} $$

> 第4章 分治策略  Divide-and-Conquer



.....



**************

### 排序

> 《算法导论》6、7、8章

**排序问题**的形式定义 ：
$$ 输入：一个含有n个数的序列<a_1,a_2,...,a_n>。\\
输出:输入序列的一个排列（重排）<a'_1,a'_2,...,a'_n>，满足a'_1 \le a'_2 \le ... \le a'_n。$$
这样的输入序列$ <a_1,a_2,...,a_n> $称为排序问题的一个**实例**，它通常是一个n元数组。
通常来说，**问题实例**由计算该问题解所需的（满足问题陈述中强加的各种约束的）输入组成。
因为大多数程序使用**排序**作为一个**中间步**，所以**排序是计算机科学中的一个基本操作**。
因此，已有许多好的**排序算法**供我们使用。

**排序的研究对象：关键字**
在实际中，待排序的数很少是单独的数值，它们通常是包含**记录（record）**的数据集的一部分。
每个记录包含一个**关键字（key）**，每个记录的关键字就是**排序的研究对象**，即排序问题中要重排的值。
记录的剩余部分由**卫星数据（satellite data）**组成，通常与关键字一同存取。
在实际中，当一个排序算法重排关键字，也必须要重排卫星数据。
如果每个记录包含大量的卫星数据，通常重排指向记录的指针的数组，而不是记录的本身，这样可以降低数据移动量。

排序算法只是为了得到有序的顺序的方法，无论我们是对单个数字排序还是对包含许多字节的卫星数据的大型记录排序。
它们是从成熟的程序中抽象出来的。
因此，**排序问题的输入通常假定是由数字组成**。
在实际应用中，我们可以从概念上轻松地将这样的排序算法转换为实际场景下的排序算法，但在处理一些细节问题的过程中会是一项挑战。

**排序的重要性**
排序是算法研究中最基础的问题，其原因有：
* 应用需要对信息进行排序。
* 很多算法需要排序作为中间步。
* 很多重要的算法设计技术都体现在多年研究者所设计的排序算法中。
* 在实现排序算法时会出现很多工程问题。

**排序算法**

|排序算法|最坏情况运行时间|平均情况\期望运行时间|说明|
|:------------:|------------|-------------------|:------------:|
|**`比较`** |           |     |    |
|  插入排序 | $\Theta(n^2)$ | $\Theta(n^2)$|   |
|  归并排序 | $\Theta(n\lg n)$ | $\Theta(n\lg n)$|  |
|  堆排序   | $O(n\lg n)$ | - |   |
|  快速排序 | $\Theta(n^2)$ | 期望：$\Theta(n\lg n)$| 背景：概率论  |
| **`其他`** |    |   |   |
|  计数排序 | $\Theta(k+n)$ | $\Theta(k+n)$|$数据项均在集合\{ 0,1,..,k \}$ |
|  基数排序 | $\Theta(d(n+k))$ | $\Theta(d(n+k))$| $每位数据项都是d位数的整数，每位数字可能取k个值$  |
|  桶排序 | $\Theta(n^2)$ | 平均：$\Theta(n)$| $假定关键字是[0,1)内服从均匀分布的n个实数$ <br>背景：概率论 |

#### `比较`排序算法

##### 0. `比较`排序算法的性质

对于`比较`排序算法，都有一个性质：
>在排序的最终结果中，各元素的次序依赖于它们之间的比较。

##### 1. 插入排序


插入排序：为了排序n个项，该算法所花时间大致等于$ {c_1}{n^2} $，其中$ c_1 $是一个不依赖于n的常数。也就是说，该算法所花时间大致与$ n^2 $成正比。

P9 插入排序
P14 插入排序的分析

对于少量元素的排序，**插入排序**是一个有效的算法。
**插入排序**的工作方式类似于**排序一手扑克牌**，具体如下：
>开始时，左手为空，且桌子上的牌面向下。
然后，每次从桌子上拿走一张牌并将它插入左手中正确的位置。
为了找到一张牌的正确位置，从右到左将它与已在手中的每张牌进行比较。
拿在左手上的牌总是排序好的，这些牌之前是桌子上牌堆中顶部的牌。

于是，将以上描述转换为伪代码算法`INSERTION-SORT`，它的参数是一个包含长度为n的要排序的数组$A[1..n]$。
该算法**原址**排序输入的数，即算法在数组A中重排这些数，在任何时候，最多只有其中的常数个数存储在数组外面。
算法`INSERTION-SORT`结束时，输入数组A包含排序好的输出序列。
算法`INSERTION-SORT`的具体伪代码描述如下：

```
INSERTION-SORT(A){
	for j=2 to A.length
		key = A[j] //选用A[j]作为当前关键字
		//Insert A[j] into the sorted sequence A[1..j-1]
		i=j-1 //前一个位置
		while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key
			A[i+1]=A[i]//后移   //将前一位置的关键字A[i]后移一个位置到A[i+1]
			i=i-1   //继续向前一个位置
		A[i+1] = key //如果前一位置的关键字A[i]小于当前关键字key,将关键字放入前一位置的关键字A[i]的后面A[i+1]		
}
```
该算法的具体描述如下：
>下标j表示正被插入到手中的`当前牌`。
>在for循环（循环变量为j）的每次迭代开始，包含元素$A[1..j-1$的子数组构成当前排序好的左手中的牌，剩余的子数组$A[j+1..n]$对应于仍在桌子上的牌堆。
>事实上，元素$A[1..j-1]$是原来在位置1到$j-1$的元素，但现在已按序排列。
>注：$A[1..j-1]$的如下性质正式地表述为**循环不变式**：
>	在for循环的每次迭代开始时，子数组$A[1..j-1]$由原来在$A[1..j-1]$中的元素组成，但已按序排列。

已经知道，关于**循环不变式**，必须要证明的三条性质：**初始化**——**保持**——**终止**。
现在开始对插入排序的**循环不变式**的三条性质进行证明：
>证明 #0：插入排序的**循环不变式**的性质——**初始化**

证明：在第一次循环迭代之前（当$j=2$时），**循环不变式**成立
子数组$A[1..j-1]$仅由单个元素$A[1]$组成，实际上就是$A[1]$原来的元素。
并且该数组是排序好的。
故在第一次循环迭代之前，**循环不变式**成立

>证明 #0：END

>证明 #1：插入排序的**循环不变式**的性质——**保持**

证明：每次迭代保持**循环不变式**。
非形式化地，for循环体的如下代码：
```
	i=j-1 //前一个位置
	while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key
		A[i+1]=A[i]//后移   //将前一位置的关键字A[i]后移一个位置到A[i+1]
		i=i-1   //继续向前一个位置
```
将$ A[j-1],A[j-2],A[j-3],.. $向右移动一个位置，直到找到$A[j]$的适当位置，执行如下代码：
```
	A[i+1] = key //如果前一位置的关键字A[i]小于当前关键字key,将关键字放入前一位置的关键字A[i]的后面A[i+1]
```
将$A[j]$的值插入该位置。
这时子数组$A[1..j-1]$由原来在$A[1..j-1]$中的元素组成，但已按序排列。
故对for循环的下一次迭代增加j将保持**循环不变式**


>证明 #1：END


>证明 #2：插入排序的**循环不变式**的性质——**终止**

考虑在循环终止时发生什么。
导致for循环终止的条件是$j \gt A.lenghth =n $。
因为 每次循环迭代j增加1，那么必有 $ j=n+1 $。
在**循环不变式**$A[1..j-1]$中，令$ j=n+1 $，有：
子数组$A[1..n]$由原来在$A[1..n]$中的元素组成，但已按序排列。

因为子数组$A[1..n]$就是整个数组，所以整个数组已排序。
故算法正确。

>证明 #2：END


现在，对**插入排序算法**进行分析。
算法`INSERTION-SORT`需要的时间依赖于**输入规模**。
我们知道，排序1000个数的时间 大于 排序3个数的时间。
此外，该算法根据两个输入序列已经排序的程度，对相同**输入规模**的两个输入序列进行排序可能会花费不同的时间。
已经知道：一般来说，算法需要的时间与**输入规模**同步增长，所以程序的运行时间是一个关于输入规模的函数。
要想**插入排序算法**的运行时间，需要分析`INSERTION-SORT`算法的每行代码的时间成本和执行次数。
首先，假设$t_j$表示对于j值执行while循环的次数。
注：当一个for或while循环按通常的方式退出时，执行次数比执行循环体的次数多1。

**表0.`INSERTION-SORT(A)`算法的时间成本和执行次数**

|| ```INSERTION-SORT(A)``` |时间成本|执行次数|
|:--:|-------------------------|:-----:|:----:|
|1|```for j=2 to A.length```|	 $c_1$	| $n$	|
|2|```	key = A[j] //选用A[j]作为当前关键字```|	$c_2$|	$n-1$|
|3|```	//Insert A[j] into the sorted sequence A[1..j-1]```| $0$ |  $n-1$ |
|4|```	i=j-1 //前一个位置```|	$c_4$	|	$n-1$	|
|5|```	while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key``` | $c_5$  | $\displaystyle \sum_{j=2}^n {t_j}$  |
|6|```		A[i+1]=A[i]//后移   //将前一位置的关键字A[i]后移一个位置到A[i+1]```| $c_6$  |  $\displaystyle \sum_{j=2}^n {(t_j-1)}$ |
|7|```		i=i-1   //继续向前一个位置		```| $c_7$  | $\displaystyle \sum_{j=2}^n (t_j-1) $ |
|8|```	A[i+1] = key //如果前一位置的关键字A[i]小于当前关键字key,将关键字放入前一位置的关键字A[i]的后面A[i+1]```|  $c_8$   | 	$n-1$	|

该算法的**运行时间**是执行每条语句的运行时间之和。
需要执行$c_i$步且执行n次的一条语句将贡献$c_i n$给总运行时间。
为计算在具有n个值得输入上，该算法的运行时间$T(n)$，将时间成本与执行次数对应元素之积求和，得：
$$ \displaystyle T(n)= c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {t_j}  + c_6 \sum_{j=2}^n (t_j-1)   +   c_7 \sum_{j=2}^n {(t_j-1)}  + c_8 (n-1)   $$



若输入数组已排好序，则出现**最佳情况**。
这时，对于每个$j=2,3,...,n$，如下代码：
```
	while i>0 and A[i]>key  //如果前一位置的关键字A[i]大于当前关键字key
```
当i取其初值$ j-1 $时，有$ A[i] \le key $，不满足这个while循环的条件，故不执行该while循环体。
从而，对$j=2,3,...,n$，有$t_j=1$。
于是，该算法的**最佳情况**运行时间是：
$$ t_j=1  \\
\displaystyle T(n)= c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {t_j}  + c_6 \sum_{j=2}^n (t_j-1)   +   c_7 \sum_{j=2}^n {(t_j-1)}  + c_8 (n-1)  \\
\displaystyle =  c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {1}  + c_6 \sum_{j=2}^n (1-1)   +   c_7 \sum_{j=2}^n {(1-1)}  + c_8 (n-1)  \\
\displaystyle = c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 (n-1)  +    c_8 (n-1) \\
\displaystyle = c_1 n +  c_2 n - c_2+  c_4 n - c_4  +  c_5 n - c_5  +    c_8 n - c_8  \\
\displaystyle = (c_1+  c_2 +  c_4 +  c_5 +    c_8)n- c_2- c_4 - c_5- c_8  \\
\displaystyle =  (c_1+  c_2 +  c_4 +  c_5 +    c_8)n - (c_2+ c_4 + c_5+ c_8 )   \\
令 a =(c_1+  c_2 +  c_4 +  c_5 +    c_8) , b=- (c_2+ c_4 + c_5+ c_8 ) ,则有：\\
T(n)= a n + b \\
因此，T(n)是一个关于n的线性函数。$$

若输入数组已反向排序，即按递减的顺序排好序，则导致**最坏情况**。
这时，必须将每个元素$A[j]$与整个已排序子数组$A[1..j-1]$中的每个元素进行比较。
所以，对$j=2,3,...,n$，有$t_j=j$，于是有：
$$\displaystyle  \sum_{j=2}^n {t_j} 
\displaystyle =\sum_{j=2}^n {j} 
\displaystyle = {n(n+1)\over 2} -1 \\ 
\displaystyle \sum_{j=2}^n (t_j-1) 
\displaystyle = \sum_{j=2}^n (j-1) 
\displaystyle =  {n(n-1)\over 2}     $$
进一步可得，该算法的**最坏情况**运行时间是
$$\displaystyle 
T(n)= c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 \sum_{j=2}^n {t_j}  + c_6 \sum_{j=2}^n (t_j-1)   +   c_7 \sum_{j=2}^n {(t_j-1)}  + c_8 (n-1)  \\
\displaystyle =  c_1 n +  c_2(n-1) +  c_4(n-1) +  c_5 ({n(n+1) \over 2} -1) + c_6 ({n(n-1)\over 2} )+   c_7 ({n(n-1)\over 2} )  + c_8 (n-1)  \\ 
\displaystyle = ({c_5 \over 2}+{c_6\over 2}+{c_7\over 2})n^2 + (c_1+c_2+c_4+{c_5 \over 2} -{c_6\over 2}-{c_7\over 2}+c_8)n - (c_2+c_4+c_5+c_8)   \\
令a= ({c_5 \over 2}+{c_6\over 2}+{c_7\over 2}), b=(c_1+c_2+c_4+{c_5 \over 2} -{c_6\over 2}-{c_7\over 2}+c_8), c= - (c_2+c_4+c_5+c_8)，则有：\\
T(n)=an^2+bn+c  \\
因此，T(n)是一个关于n的二次函数。$$



##### 2. 归并排序

归并排序：为了排序n个项，该算法所花时间大致等于$ {c_2} n \lg n $，其中$ \lg n $代表$ \log_2 n  $，且$ c_2 $是一个不依赖于n的常数。

P17 归并排序
P20 归并排序的分析


**归并排序算法**完全遵循**分治算法**，在每层递归时都有三个子步骤：
* 分解：分解待排序的n个元素的序列成两个分别具有${n \over 2}$个元素的子序列。
* 解决：使用**归并排序**递归地排序两个子序列。
* 合并：合并两个已排序的子序列以产生已排序的答案。

当待排序的序列长度为1时，回归到起点，在这种情况下由于长度为1的每个序列都已排好序，故不需要做任何工作。

**2.1 辅助算法`MERGE(A,p,q,r)`**

**归并排序算法**的关键操作是**合并**步骤中两个已排序序列的合并。
这时，需要一个**辅助算法`MERGE(A,p,q,r)`**完成合并工作，其中A是一个数组，p、q、r是数组下标，且$ p \le q \lt r $。
算法`MERGE(A,p,q,r)`做出了假设：子数组$A[p...q]$和$ A[q+1...r] $都已排好序。
该算法主要的工作是：合并两个子数组$A[p...q]$和$ A[q+1...r] $形成单一的已排好序的子数组并代替当前的子数组$A[p...r]$。

**辅助算法`MERGE(A,p,q,r)`**的具体工作如下：
>回到扑克牌上来，假设桌子上有两堆牌（明牌展示），它们都已排序，第一张牌是最小的。
>我们想要把这两堆牌合并成单一的排好序的输出堆，在桌子上暗牌展示。
>我们的**基本步骤**是：在明牌的两堆牌的首张牌中选取其中较小的一张，将这张牌拿出来，以暗牌方式放到输出堆。
>这样，持续进行这个基本步骤，直到明牌的两堆牌中的其中一堆被取完为止，随后，将剩余的一堆牌放到输出堆。

>注意：因为只是比较明牌的两堆牌的首张牌，所以每个基本步骤需要常量时间。
>并且，因为最多执行$n=r-p+1$（待合并元素的总数）个基本步骤，所以合并需要$\Theta(n)$的时间。

如果用伪代码描述**辅助算法`MERGE(A,p,q,r)`**，需要做一个额外的变化，以避免在每个基本步骤必须检查是否有堆为空，于是在每个堆的底牌放置一张**哨兵**牌，包含一个特殊值（这里选用$ \infty $），用于简化代码。
这样，就可以用伪代码描述该辅助算法了，具体如下：
```
//假设：子数组A[p...q]和A[q+1...r]都已排好序。
//主要的工作是：合并两个子数组A[p...q]和A[q+1...r]形成单一的已排好序的子数组并代替当前的子数组A[p...r]。
MERGE(A,p,q,r){
	n1 = q-p+1  //第一个子数组A[p...q]的大小
	n2 = r-q // 第二个子数组A[q+1...r]的大小
	let L[1..n1+1] and R[1..n2+1] be new arrays // L是A[p...q]+哨兵元素A[n1+1]  R是A[q+1...r]+哨兵元素A[n2+1]
	for i=1 to n1
		L[i]=A[p+i-1]  //将A[p...q]的内容填入L[1..n1+1]
	for j=1 to n2
		R[i]=A[q+j]   //将A[q+1...r]的内容填入R[1..n2+1]
	L[n1+1]= ∞ //L哨兵元素=无穷
	R[n2+1]= ∞ //R哨兵元素=无穷
	i=1
	j=1
	for k=p to r  //从A数组的开头位置p开始 to A数组的尾部位置r  合并的基本步骤
		if L[i] <= R[j]
			A[k]=L[i]  //L[i]最小
			i = i + 1
		else
			A[k]=R[j]  //R[j]最小
			j = j + 1
}
```
**辅助算法`MERGE(A,p,q,r)`**的详细工作过程如下：
>计算子数组$A[p...q]$的长度$n_1$
>计算子数组$A[q+1...r]$的长度$n_2$
>创建长度为$n_1 + 1$和$n_2 + 1$的数组L和R（左和右），每个数组中额外的位置保存哨兵。
>将$A[p...q]$的内容填入$L[1..n1+1]$
>将$A[q+1...r]$的内容填入$R[1..n2+1]$
>将哨兵放在数组L和R的末尾部。
>开始进行合并的基本步骤，循环选出最小并填入A的后半部。

注意，在进行合并的基本步骤，代码如下：
```
	i=1
	j=1
	for k=p to r  //从A数组的开头位置p开始 to A数组的尾部位置r  合并的基本步骤
		if L[i] <= R[j]
			A[k]=L[i]  //L[i]最小
			i = i + 1
		else
			A[k]=R[j]  //R[j]最小
			j = j + 1
```
这时，维持着如下**循环不变式**，执行了$n=r-p+1$个基本操作：
>在开始如上的for循环的每次迭代时，子数组$A[p...k-1]$按从小到大的顺序包含$L[1..n_1+1]$和$R[1..n_2+1]$ 中的$k-p$个最小元素。进而，L[i]和R[j]是各自所在数组中未被复制到数组A的最小元素。


已经知道，关于**循环不变式**，必须要证明的三条性质：**初始化**——**保持**——**终止**。
现在开始对**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的三条性质进行证明，得出如下结论：
>如上for循环的第一次迭代之前以上的**循环不变式**成立，该循环的每次迭代保持这个**循环不变式**，并且循环终止时，这个**循环不变式**提供了一种有用的性质证明了正确性。

具体证明如下：
>证明 #0：**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的性质——**初始化**



>证明 #0：END

>证明 #1：**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的性质——**保持**



>证明 #1：END


>证明 #2：**辅助算法`MERGE(A,p,q,r)`**中的**循环不变式**的性质——**终止**



>证明 #2：END

现在，对**辅助算法`MERGE(A,p,q,r)`**进行分析。
在**辅助算法`MERGE(A,p,q,r)`**的伪代码中，首先，如下两段代码，它们每行需要常数时间：
```
	n1 = q-p+1  //第一个子数组A[p...q]的大小
	n2 = r-q // 第二个子数组A[q+1...r]的大小
	let L[1..n1+1] and R[1..n2+1] be new arrays // L是A[p...q]+哨兵元素A[n1+1]  R是A[q+1...r]+哨兵元素A[n2+1]
```
```
	L[n1+1]= ∞ //L哨兵元素=无穷
	R[n2+1]= ∞ //R哨兵元素=无穷
	i=1
	j=1
```
然后，如下两个for循环，需要$\Theta(n_1+n_2)=\Theta(n)$的时间
```
	for i=1 to n1
		L[i]=A[p+i-1]  //将A[p...q]的内容填入L[1..n1+1]
	for j=1 to n2
		R[i]=A[q+j]   //将A[q+1...r]的内容填入R[1..n2+1]
```
最后，如下进行合并的基本步骤的for循环有n次迭代，每次迭代需要常量时间：
```
	for k=p to r  //从A数组的开头位置p开始 to A数组的尾部位置r  合并的基本步骤
		if L[i] <= R[j]
			A[k]=L[i]  //L[i]最小
			i = i + 1
		else
			A[k]=R[j]  //R[j]最小
			j = j + 1
```
因此，**辅助算法`MERGE(A,p,q,r)`**的运行时间$ T(n)=\Theta(n) $。

**2.2 归并排序算法`MERGE-SORT(A,p,r)`**

有了**辅助算法`MERGE(A,p,q,r)`**，就可以很容易地写出**归并排序算法`MERGE-SORT(A,p,r)`**。
**归并排序算法`MERGE-SORT(A,p,r)`**的目的是：排序子数组$A[p...r]$中的元素。
若$p \ge r$，则子数组A最多有一个元素，所以已经排好序。
若$p \lt r$，则分解步骤简单地计算一个下标q，将$A[p...r]$分成两个子数组$A[p...q]$和$A[q+1...r]$。
对于子数组$A[p...q]$，包含$\lceil{n\over 2}\rceil$个元素。
对于子数组$A[q+1...r]$，包含$\lfloor{n\over 2}\rfloor$个元素。

如果用伪代码描述**归并排序算法`MERGE-SORT(A,p,r)`**，于是有：
```
//初始调用MERGE-SORT(A,1,A.length)
//A.length=n
MERGE-SORT(A,p,r){
	if p<r
		q = floor((p+r)/2)
		MERGE-SORT(A,p,q)
		MERGE-SORT(A,q+1,r)
		MERGE(A,p,q,r)
}
```
当数组A的长度A.length为$2^k$(k为任意正整数)时，**归并排序算法`MERGE-SORT(A,p,r)`**由以下操作组成：
>合并只含有1项的序列对形成长度为2的排好序的序列，
>合并长度为2的序列对形成长度为4的排好序的序列，
>持续下去，
>直到长度为${n\over 2}$的两个序列被合并最终形成长度为n的排好序的序列。



现在分析**归并排序算法`MERGE-SORT(A,p,r)`**。
虽然**归并排序算法`MERGE-SORT(A,p,r)`**在元素的数量不是偶数时也能正确地工作，但是，如果假定问题规模是$2^k$(k为任意正整数)，那么基于递归式的分析将被简化。
这时，每个分解步骤将产生规模刚好为${n\over 2}$的两个序列。

由于**归并排序算法**完全遵循**分治算法**，因此现在建立n个数的最坏情况运行时间$T(n)$的递归式。
* 当使用**归并排序算法**对一个元素排序时，需要$\Theta(1)$的常数时间。
* 当有$n>1$个元素时，分解运行时间如下：
	* 分解：分解步骤仅仅计算子数组的中间位置，需要常数时间，因此$D(n)=\Theta(1)$。
	* 解决：递归地求解两个规模均为${n\over 2}$的子问题，将贡献$2T({n\over 2})$的运行时间。
	* 合并：在一个具有n个元素的子数组上执行**辅助算法`MERGE(A,p,q,r)`**需要$\Theta(n)$的时间，所以$C(n)=\Theta(n)$。
	* 于是有，当$n>1$时，需要$$ D(n)+2T({n\over 2})+C(n) \\
   =\Theta(1)+2T({n\over 2})+\Theta(n) \\
   =2T({n\over 2})+\Theta(n) $$的时间。

综上所述，**归并排序算法**的最坏情况运行时间$T(n)$的递归式有：
$$ T(n) = \begin{cases}
   \Theta(1) &\text{if } n=1 \\
    2T({n\over 2})+\Theta(n) &\text{if } n \gt 1
\end{cases} $$
这时，需要**主定理**求解这个递归式，并且最终解得$T(n)=\Theta(n \lg n)$。
因为对数函数比任何线性函数增长要慢，所以对于**足够大的输入**，最坏情况运行时间为$\Theta(n \lg n)$的**归并排序算法**将**优于**最坏情况运行时间为$\Theta(n^2)$的**插入排序**。

>Q #0：如何用**递归树**证明$T(n)=\Theta(n \lg n)$？

P21 2.3.2 分析分治算法

>Q #0：END


##### 3. 堆排序
> 参照：“算法之杖”的（二叉）堆


##### 4. 快速排序


**快速排序**遵循**分治算法**思想，它的研究对象是**一个子数组$A[p..r]$**，对这个子数组$A[p..r]$进行如下分治过程：
* **分解**：首先计算划分下标q，在将子数组$A[p..r]$划分为两个可能为空的子数组$A[p..q-1]$和$A[q+1..r]$，使得满足如下条件：$ A[p..q-1]的所有元素 \le A[q] \le A[q+1..r]的所有元素 $。
* **解决**：递归地调用快速排序（这个分治过程），对子数组$A[p..q-1]$和$A[q+1..r]$进行排序。
* **合并**：由于子数组$A[p..r]$都是原址排序，所以不需要合并操作。

为了更好地理解**快速排序**，继续用扑克牌作为例子：
>目前，在桌子上有一摞扑克牌，这摞牌处于无序状态，并且以暗牌（背面朝向上）方式展示。
>将这张桌子划分为**标准点区**、**小号区**、**大号区**、**牌堆区**。
>把这摞无序的牌放到**牌堆区**。
>任务：要将这摞无序的牌进行排序。
>1.首先，从这摞牌中取出第一张牌或最后一张牌，放置到**标准点区**，并称这张牌为**标准牌**。
>2.开始在**牌堆区**中取牌：
>（1） 如果所取得的牌**小于**标准牌，就将这张所取得的牌放到**小号区**。
>（2）如果所取得的牌**大于**标准牌，就将这张所取得的牌放到**大号区**。
>（3）持续进行取牌，直到取完牌堆区的牌。
>这时，得到两堆无序的牌：大号区的牌和小号区的牌。
>接着分别对这两堆牌进行同样的动作。
>最后，就完成了整个排序任务。


###### 4.1.  辅助算法`PARTITION(A,p,r)`
**快速排序**将分解步骤编写为一个**辅助算法`PARTITION(A,p,r)`**。
要想将子数组$A[p..r]$划分为两个可能为空的子数组$A_l$和$A_r$，需要在$A[p..r]$中选用一个**标准点（主元pivot element）**，作为子数组$A_l$和$A_r$的界线。
在选好**标准点（主元pivot element）**之后，

至于如何在$A[p..r]$中选用这个**标准点（主元pivot element）**，有许多不同的方案。这些方案都影响着**辅助算法`PARTITION(A,p,r)`**的执行时间。
通常，选用$A[p..r]$的首元素或尾元素作为**标准点（主元pivot element）**。
1.选用$A[p..r]$的**首元素$A[p]$**作为**标准点（主元pivot element）**

当**首元素$A[p]$**作为标准点时，**辅助算法`PARTITION(A,p,r)`**的伪代码描述如下：
```
PARTITION(A,p,r){

}
```

2.选用$A[p..r]$的**尾元素$A[r]$**作为**标准点（主元pivot element）**

当**尾元素$A[r]$**作为标准点时，**辅助算法`PARTITION(A,p,r)`**的伪代码描述如下：
```
PARTITION(A,p,r){
	x=A[r] //选择尾元素A[r]作为标准点，放在标准点区
	i=p-1 //数组A_l的循环变量i，它始终指向小号区的最后一个元素
	for j=p to r-1   //在牌堆逐一取牌
		if A[j]<= x  //选出小号区的牌
			i=i+1
			exchange A[i] with A[j] //将所取得的牌放到小号区
		//这里，大号区与牌堆区合并，
		//属于大号区的牌继续在牌堆区
	exchange A[i+1] with A[r] //将标准点放到小号区和大号区（牌堆区）的中间。
}
```
在**辅助算法`PARTITION(A,p,r)`**中，for循环的每一轮迭代的开始，标准点区、大号区、小号区、牌堆区都满足如下性质，这些性质就是**循环不变式**：
>for循环的每一次迭代开始时，对于任意数组下标k，有：
>1.若$p \le k \le i$，则$A[k] \le x$.
>2.若$i+1 \le k \le j-1$，则$A[k]  \gt x$。
>3.若$k=r$，则$A[k]=x$。

该**循环不变式**的具体证明如下：
>证明 #0：**辅助算法`PARTITION(A,p,r)`**中的**循环不变式**的性质——**初始化**



>证明 #0：END

>证明 #1：**辅助算法`PARTITION(A,p,r)`**中的**循环不变式**的性质——**保持**



>证明 #1：END


>证明 #2：**辅助算法`PARTITION(A,p,r)`**中的**循环不变式**的性质——**终止**



>证明 #2：END


**辅助算法`PARTITION(A,p,r)`**在子数组$A[p..r]$上的时间复杂度是$\Theta(n=r-p+1)$。


###### 4.2.  算法`QUICKSORT(A,p,r)`

在辅助算法`PARTITION(A,p,r)`的基础上用伪代码描述算法`QUICKSORT(A,p,r)`，则有：
```
//为了排序一个数组A的全部元素，初始调用是QUICKSORT(A,1,A.length)
QUICKSORT(A,p,r){
	if p<r
		q=PARTITION(A,p,r)
		QUICKSORT(A,p,q-1)
		QUICKSORT(A,q+1,r)
}
```

现在，对**快速排序**进行非形式化地分析：
**快速排序**的运行时间依赖于划分是否平衡，而平衡又依赖于用于划分的元素。
如果划分是平衡的，那么**快速排序**的性能与归并排序一样，即$\Theta(n \lg n)$。
如果划分是不平衡的，那么**快速排序**的性能就接近于插入排序的性能，即$\Theta(n^2)$。
（1）最坏情况的划分
在最坏情况下，划分产生两个子问题是n-1个元素和0个元素。
假设：算法`QUICKSORT(A,p,r)`的每一次递归都出现这样的划分。
划分操作的时间复杂度是$\Theta(n)$。
对于0个元素的数组，它的时间复杂度是$\Theta(1)$
于是，算法`QUICKSORT(A,p,r)`的运行时间的递归式为：
$$ T(n)=T(n-1)+T(0)+\Theta(n) \\
=T(n-1)+\Theta(n)$$
利用**代入法**求得该递归式：
$$ T(n)=T(n-1)+\Theta(n) \\
=\Theta(n^2)$$

在最坏情况下，**快速排序**的运行时间并不比插入排序更好。
如果输入数组是有序的，**快速排序**的最坏情况运行时间依然是$\Theta(n^2)$。
反观插入排序，在输入数组是有序的时，插入排序的最坏情况运行时间却是$\Theta(n)$

（2）最好情况的划分
在可能的最平衡的划分中，所划分的两个子问题都是不大于${n\over 2}$个元素的数组：
* 一个$\lfloor {n\over 2}\rfloor$个元素的数组
* 一个$\lceil {n\over 2}\rceil -1 $个元素的数组

这种情况下的**快速排序**的性能非常好，算法`QUICKSORT(A,p,r)`的运行时间的递归式为（忽略了一些余项和常数项）：
$$ T(n)=2 T({n\over 2}) + \Theta(n) $$
根据**主定理**的CASE 2，求得该递归式的解为$T(n)=\Theta(n \lg n)$


###### 4.3.  随机化算法`RANDOMIZED-QUICKSORT(A,p,r)`

```
RANDOMIZED-PARTITION(A,p,r){
	i=RANDOM(p,r)
	exchange A[r] with A[i]
	return PARTITION(A,p,r)
}
```
...
```
RANDOMIZED-QUICKSORT(A,p,r){
	if p<r
		q=RANDOMIZED-PARTITION(A,p,r)
		RANDOMIZED-QUICKSORT(A,p,q-1)
		RANDOMIZED-QUICKSORT(A,q+1,r)
}
```
...
###### 4.4. **快速排序**的分析

现在，对**快速排序**进行形式化地分析：

...





#### `比较`排序算法的总结

在以上这些能在$O(n \lg n)$时间内排序n个数的算法中，**归并排序**和**堆排序**达到了最坏情况下的上界，**快速排序**在平均情况下达到$O(n \lg n)$的上界。
而且，对于这些算法的每一个，给定n个输入数值，都能在$\Omega(n \lg n)$时间内完成。

下面将要证明：
> 证明：$$ 在最坏情况下，任何比较排序算法都需要做\Omega(n \lg n)次比较。 $$

**已知**：在比较排序算法中，只使用元素间的比较获得输入序列$< a_1,a_2,...,a_n >$中的元素间次序的信息。
这表明，给定两个元素$a_i$和$a_j$，可以执行$a_i \lt a_j , a_i \le a_j , a_i = a_j , a_i \ge a_j , a_i \gt a_j$中的一个比较操作确定它们之间的相对次序。
**假设**：所有的输入元素都是互异的。
这时，$a_i = a_j $就被舍去，$ a_i \lt a_j $等价于$a_i \le a_j$，$a_i \gt a_j$等价于$a_i \ge a_j $。
进一步**假设**：所有比较采用的都是$a_i \le a_j$。

首先，将**比较排序**抽象为一棵**决策树**。
对于**决策树**，它是一棵完全二叉树，用于表示**在给定输入规模下，某一特定排序算法对所有元素的比较操作**。
注意：**决策树**忽略了~~控制~~,~~数据移动~~等其他操作。

在**决策树**中，每个内部结点都以$< i : j >$（$1\le i，j \le n且n是输入序列中的元素个数 $）标记，每个叶子节点上都标注一个序列$< \pi(1),\pi(2),...,\pi(n) >$。
排序算法的执行对应于一条从树的根结点到叶子结点的路径。
每个内部结点表示一次比较（$a_i \le a_j$）。
左子树表示一旦确定$a_i \le a_j$之后的后续比较。
右子树表示一旦确定$a_i \gt a_j$之后的后续比较。
当到达一个叶子结点时，表示排序算法已经完成排序并得到序列$ \pi(1) \le  \pi(2) \le ... \le \pi(n) $。
因为任何正确的排序算法都能够生成输入的每一个排列，所以：
对于一个正确的比较排序算法来说，n个元素的$n!$种可能的排列都应该出现在决策树的叶子结点上，并且，每一个叶子结点都必须是可以从根结点经由某条路径到达的，该路径对应于比较排序的一次实际执行过程。
因此，**假设**：每一种排列都是一个可达的叶子结点的决策树。

在**决策树**中，从根结点到任意一个可达叶子节点之间最长简单路径的长度，对应于排序算法中最坏情况下的比较次数。
因此，一个比较排序算法中的最坏情况比较次数就是**其决策树的高度**。
于是，当决策树中每种排列都是以可达的叶子结点的形式出现时，该决策树高度的下界就是比较排序算法运行时间的下界。

现在考虑一棵高度为h、具有l个可达叶子结点的决策树，它对应一个对n个元素所做的比较排序。
因为输入数据的$n!$种可能的排列都是叶子结点，所以有：
$$ n! \le l $$
由于在一棵高为h的二叉树中，叶子结点的数目$\le 2^h$，因此有：
$$ n! \le l  \le 2^h$$
对该不等式两边取对数，有：
$$ h \ge \lg(n!) \\
=\Theta(n \lg n)
= \Omega(n \lg n) $$

> 证明：END

> 推论：堆排序和归并排序都是渐近最优的比较排序算法。

堆排序和归并排序的运行时间的上界为$O(n \lg n)$ 与 最坏情况下的下界$\Omega(n \lg n) $一致。

> 推论：END

#### `其他`排序算法

##### 1. 计数排序

**计数排序**假设n个输入元素中的每一个都是在0到k区间的一个整数，其中k为某个整数。
当$k=O(n) $时，**计数排序**的运行时间是$\Theta(n)$。

**计数排序**的基本思想是：对每一个输入元素x，确定小于x的元素个数。这样，就可以把x放到它在输出数组中的位置上。当有几个元素相同时，由于不能把它们放在同一位置上，所以需要对**计数排序**进行稍作改进。

**计数排序**的具体描述：
>现在有一个包含8个元素的输入数组$A=\{2,5,3,0,2,3,0,3\}$，给定一个同样包含8个元素的输出数组$B=\{0,0,0,0,0,0,0,0\}$。
>由于数组A的最大值是5，故数字的范围是$0..5$。
>现在进行**统计每个数字出现的次数**：

$$2个数字0 \\
0个数字1 \\
2个数字2 \\
3个数字3 \\
0个数字4 \\
1个数字5$$

>出现了5个数字。
>如果按顺序排序，可得统计结果如下表格：

| 0   |  1  |   2  |   3  |  4  |  5  |
|:-----:|:-----:|:------:|:------:|:-----:|:------:|
| 0,0 |     |  2,2 | 3,3,3 |    |   5   |
|	2  |  0  |   2   |   3   | 0   |  1   |

>由于数组A存在重复元素，要想把排序的结果填入到数组B，为了避免填入在同一位置，需要**提前计算每个数字出现在数组B的最大位置**。
>至于如何计算每个数字出现在数组B的最大位置，假设我们想要知道**数字3出现在数组B的最大位置**，已经知道数字3在数组A的个数是3，它就是数字3在数组B的所占的空间，即3个位置。
>但是数字3在数组B的所占的空间的具体位置（起始位置）在哪里？
>我们知道，数字3的前面还有数字0、数字1和数字2。
>于是就能确定：数字3在数组B的所占的空间的具体位置（起始位置）就是数字0、数字1和数字2的总空间，即：
>$$在数组B中，数字3的具体位置=数字0所占的空间+数字1所占的空间+数字2所占的空间$$
>所以，就得到了**数字3出现在数组B的最大位置**，即：
>$$在数组B中，数字3的最大位置 = 数字3所占的空间 + 数字3的具体位置\\
>= 数字3所占的空间 + (数字0所占的空间+数字1所占的空间+数字2所占的空间)$$
>同理，从数字0到数字5，它们的最大位置有：

$$数字0的最大位置  = 数字0所占的空间$$
$$数字1的最大位置  = 数字1所占的空间 + 数字0所占的空间 \\
= 数字1所占的空间 + 数字0的最大位置$$
$$数字2的最大位置  = 数字2所占的空间 + (数字1所占的空间 + 数字0所占的空间) \\
= 数字2所占的空间 + (数字1所占的空间 + 数字0的最大位置)\\
= 数字2所占的空间 + 数字1的最大位置$$

>综上所述，就得到了**每个数字出现在数组B的最大位置**，即：

$$在数组B中， 数字i的最大位置 = 数字i所占的空间 + 数字(i-1)的最大位置 $$

>现在，对统计结果进行全新的改动：

|数字i| 0   |  1  |   2  |   3  |  4  |  5  |
|-|:-----:|:-----:|:------:|:------:|:-----:|:------:|
|排序结果| 0,0 |     |  2,2 | 3,3,3 |    |   5   |
|出现次数|	2  |  0  |   2   |   3   | 0   |  1   |
| 最大位置|  2 |  2  |   4   |   7   |   7 |  8   |

>由于将排序结果填入到数组B不仅需要数字的最大位置，还需要数字的每一个位置，故需要在填入过程中，先填入数组，再对数字的最大位置进行递减，使得下一次填入的使用。
>现在考虑**如何填入到数组B**，首先要从数组A中拿到数字i，然后根据数字i获得该数字在数组B的位置，接着填入到数组B。
>这样，就可以得到数组$B=\{0,0,2,2,3,3,3,5\}$。




算法`COUNTING-SORT(A,B,k)`的伪代码描述如下：
```
//输入是一个数组A[1..n],A.length=n
//输出是一个数组B[1..n]存放排序的输出
//临时数组C[0..k]提供临时存储空间
COUNTING-SORT(A,B,k){
	let C[0..k] be a new array
	for i=0 to k  //初始化C[0..k]  i=k
		C[i]=0
	for j=1 to A.length  //遍历数组A，
		C[A[j]]=C[A[j]]+1  //对数组A的每一个元素进行统计每个数字出现的次数，结果存放在数组C
	//C[i] now contains the number of elements equal to i
	for i=1 to k    //统计每个数字（下标）在数组B的最大位置
		C[i]=C[i]+C[i-1]
	//C[i] now contains the number of elements less than or equal to i
	for j=A.length downto 1
		B[C[A[j]]]=A[j]		//填入数组B：从数组A中拿到数字i，然后根据数字i获得该数字在数组B的位置，接着填入到数组B。
		C[A[j]]=C[A[j]]-1  //获得数字的前一个位置
}
```

考虑**计数排序**的运行时间，第一个for循环需要$\Theta(k)$，第二个循环需要$\Theta(n)$，第三个循环需要$\Theta(k)$，第四个for循环需要$\Theta(n)$，所以，**计数排序**的运行时间是$\Theta(k+n)$。
在实际工作中，当$k=O(n)$时，一般采用**计数排序**，因为这时的运行时间是$\Theta(n)$。
**计数排序**是使用输入元素的实际值确定其在数组上的位置，因此**计数排序**的下界要优于$\Omega(n\lg n)$。

由于**计数排序**具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同，因此，它是稳定的。
这表明，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。
但只有当进行排序的数据还附带卫星数据时才能体现**计数排序**的稳定性。
此外，由于**计数排序**的稳定性，它经常被用作**基数排序**的辅助算法。


##### 2. 基数排序

**基数排序（radix sort）**是一种用在卡片排序机上的算法。
一张卡片有80列，在每一列上机器可以选择在12个位置中的任一处穿孔。
通过机械操作，可以对排序机“编程”，从而检查每个卡片中的给定列，然后根据穿孔的位置将它们分别放入12个容器中。
接着，操作员就可以逐个地从容器收集卡片。
对于十进制数字来说，每列只会用到10个位置，其他两个位置用于编码非数值字符。
一个d位数占用d列。
因为卡片排序机一次只能查看一列，所以：
要对n张卡片上的d位数进行排序，就需要设计一个排序算法。

**基数排序（radix sort）**首先按**最低有效位**进行排序，然后将所有卡片合并在一叠。
之后，用同样的方法按**次低有效位**对所有卡片进行排序。
重复这一过程，直到对所有的d位数字都进行排序。
最后，所有卡片已按d位数完全排好序。
所以，对这一叠卡片的排序仅需要进行d轮。

为了确保**基数排序**的正确性，一位数排序算法必须是稳定的。
卡片排序机所执行的排序是稳定的，但操作员必须确保卡片从容器中被取出时不改变顺序，即使一个容器中的所有卡片在该位都是相同的数字也要确保稳定。

在一台典型的串行随机存取计算机（RAM模型）中，有时会用**基数排序**对具有多关键字域的记录进行排序。
>例如，用三个关键字（年、月、日）对日期进行排序。
>一般做法是：使用基于特殊比较函数的排序算法，先比较年，如果相同，再比较月，如果相同，就比较日。
>特殊做法是：使用一种稳定排序算法对这些信息进行三次排序，即日---月---年。

下面是算法`RADIX-SORT(A,d)`的伪代码描述：
```
RADIX-SORT(A,d){
	for i=1 to d
		use a stable sort to sort array A on digit i  //使用计数排序算法
}
```

>引理 0：给定n个d位数，其中每一个数位有k个可能的取值。如果`RADIX-SORT(A,d)`使用的稳定排序方法需要$\Theta(n+k)$时间，那么它就可以在$\Theta(d(n+k) )$时间内将这些数排好序。
>引理 0：END

当d为常数且$k=O(n)$时，**基数排序**具有线性时间。
在更一般的情况下，可以灵活地决定如何将每个关键字分解成若干位。

>引理 1：给定一个b位数和任何正整数$r \le b$，如果`RADIX-SORT(A,d)`使用的稳定排序算法对数据取值区间是0到k的输入进行排序需要$\Theta(n+k)$时间，那么它就可以在$\Theta( ({b\over r}) (n+2^r)  )$的时间内将这些数排好序。
>引理 1：END

>Q #0 : **基数排序**是否比基于比较的排序算法更好呢？
>Q #0：END


##### 3. 桶排序

**桶排序（bucket sort）**假设输入数据服从均匀分布，平均情况下它的运行时间是$O(n)$。

**桶排序（bucket sort）**假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在$[0,1)$区间上。

**桶排序（bucket sort）**将$[0,1)$区间划分为n个相同大小的子区间（桶），然后，将n个输入数分别放到各个桶中，因为输入数据是均匀、独立地分布在$[0,1)$区间上，所以一般不会出现很多数落在同一个桶中的情况，为了得到输出结果，**先对每个桶中的数进行排序，然后遍历每个桶，按次序把各个桶中的元素列出来即可**。

下面是算法`BUCKET-SORT(A)`的伪代码描述：
```
//输入：一个包含n个元素的数组A，且每个元素A[i]满足[0,1)区间。
//一个临时数组B[0..n-1],用于存放链表（桶）
//假设：存在一种用于维护链表的机制。
BUCKET-SORT(A){
	n =A.length
	let B[0..n-1] be a new array
	for i=0 to n-1
		make B[i] an empty list
	for i=1 to n
		insert A[i] into B[floor(n*A[i])]
	for i=0 to n-1
		sort list B[i] with insertion sort
	concatenate the lists B[0],B[1],..B[n-1] together in order
}
```

验证算法的正确性

...


分析桶排序的运行时间


...




### 顺序统计量

> 《算法导论》9章 中位数和顺序统计量

在一个由n个元素组成的集合中，第i个**顺序统计量（order statistic）**是该集合中第i小的元素。
在该集合中，**最小值**是第1个顺序统计量，**最大值**是第n个顺序统计量。
用非形式化的描述来说，一个**中位数（median）**是它所属集合的“中点元素”。
当n为奇数时，这个中位数是唯一的，位于$ i={(n+1) \over 2} $的位置上。
当n为偶数时，存在两个中位数，分别是：
* 位于$ i={n \over 2} $的位置上
* 位于$ i={n\over 2}+1 $的位置上

如果不考虑n的奇偶性，中位数总是出现在$ i=\lfloor {(n+1) \over 2} \rfloor  $（**下中位数**）处和$ i=\lceil {(n+1) \over 2} \rceil $（**上中位数**）处。
但这里选用$ i=\lfloor {(n+1) \over 2} \rfloor  $处的**下中位数**作为**中位数**。

这里主要研究的问题是：从一个由n个互异的元素构成的集合中**选择**第i个顺序统计量的问题，即**一般选择问题**。
>Q #0：（**一般选择问题**）从一个由n个互异的元素构成的集合中**选择**第i个顺序统计量的问题？

对**一般选择问题**进行形式化定义如下：
$$ 输入：一个包含n个（互异的）数的集合A和一个整数i，1 \le i \le n。\\
  输出：元素x \in A，且A中恰好有i-1个其他元素小于它。 $$

首先，令输入中的整数$ i=1 $，这时，将这个选择问题转换为从一个由n个互异的元素构成的集合中**选择**最小值。
>Q #0.1：（**选择最小值问题**）从一个由n个互异的元素构成的集合中**选择**最小值。

Q：在一个有n个元素的集合中，需要做多少次比较才能确定其最小元素？
A：通过**依次遍历集合中的每个元素，并记录下当前最小元素**的方法，最多可做$ n-1 $次比较。
如果用伪代码描述`MINIMUM`算法，则有：
```
//假设：集合元素存放在数组A中，且A.length=n
MINIMUM(A){
	min=A[1]
	for i=2 to A.length
		if min > A[i]
			min=A[i]
	return min
}
```
对于任意一个确定最小值的算法，可以把它看成是在各个元素之间进行的一场锦标赛。
每次比较都是锦标赛中的一场比赛，两个元素中较小的获胜。
注：除了最终获胜者以外，每个元素都至少要输掉一场比赛。
因此，为了确定最小值，必须要做$n-1$次比较。
所以，从所执行的比较次数来看，算法`MINIMUM`是最优的。

>Q #0.1：END

然后，令输入中的整数$i=n$，这时，将这个选择问题转换为从一个由n个互异的元素构成的集合中**选择**最大值。
>Q #0.2：（**选择最大值问题**）从一个由n个互异的元素构成的集合中**选择**最大值。

显然，**选择最大值问题**与**选择最小值问题**类似，于是`MAXIMUM`算法，如下所示：
```
//假设：集合元素存放在数组A中，且A.length=n
MAXIMUM(A){
	max=A[1]
	for i=2 to A.length
		if max < A[i]
			max=A[i]
	return max
}
```
同样，对于任意一个确定最大值的算法，也可以把它看成是在各个元素之间进行的一场锦标赛。
由于与**选择最小值问题**类似，因此，为了确定最大值，必须要做$n-1$次比较。
所以，从所执行的比较次数来看，算法`MAXIMUM`是最优的。
>Q #0.2：END

接着，考虑**同时找出一个包含n个元素的集合中的最小值和最大值**的新问题。
>Q #0.3：（**同时选择最小值和最大值**）同时找出一个包含n个元素的集合中的最小值和最大值？

存在两种方法：
* 分别执行上述的`MINIMUM`算法和`MAXIMUM`算法，得到最小值和最大值：它们各需要比较$n-1$次比较，共$2n-2$次比较，于是得到渐近最优的$\Theta(n)$次比较。
* 记录已知的最小值和最大值，对输入元素成对地进行处理：
	* 首先，将一对输入元素相互进行比较，
	* 然后，把较小的与当前最小值比较，把较大的与当前最大值进行比较。
这样，对每个元素共需3次比较。

对于第二种方法，如何设定已知的最小值和最大值的初始值依赖于**n是奇偶性**。
若n是奇数，则将最大值和最小值都设置为第一个元素的值，然后成对地处理余下的元素。
若n是偶数，则对前两个元素做一次比较，以决定最小值和最大值的初值，然后成对地处理余下的元素。
第二种方法的总比较此数也依赖于**n是奇偶性**。
若n是奇数，则总共进行$ 3 \lfloor {n \over 2} \rfloor $次比较。
若n是偶数，则先进行一次初始比较，然后进行$ {3(n-2) \over 2} $次比较，共${3n \over 2}-2$次比较。
因此，无论哪种情况，总的比较次数至多是$ 3 \lfloor {n \over 2} \rfloor $。

>Q #0.3：END


最后，回到**一般选择问题**上来。
对于**一般选择问题**，存在三种算法：
* 简单的选择算法：通过将输入集合排序，取输出的第i个元素选择第i个顺序统计量。
* 期望为线性时间的选择算法
* 最坏情况为线性时间的选择算法

后两种算法都参照了**快速排序**模型。

。。。



>Q #0：END

******
